<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<link rel="stylesheet" href="../../styles/lesson.css">
<title>Quantization & Artifacts (JPEG Part II)</title>
<script>
window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<style>
  /* Section 7 - Quantization Slider Styles */
  .stats-bar {
      display: flex;
      justify-content: space-around;
      background: #f8fafc;
      padding: 10px;
      border-radius: 10px;
      margin-bottom: 15px;
      border: 1px solid #e2e8f0;
  }
  .stat-item {
      text-align: center;
  }
  .stat-label {
      display: block;
      font-size: 0.7rem;
      color: #64748b;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 2px;
      font-weight: 600;
  }
  .stat-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: #2d3748;
      font-family: monospace;
  }
  .stat-value.highlight {
      color: #667eea;
  }
  #quantCanvas {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      margin-bottom: 15px;
      max-width: 100%;
      height: auto;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
  }
  .controls-container {
      background: white;
      padding: 15px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
  }
  .quality-slider {
      width: 100%;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #e2e8f0;
      border-radius: 4px;
      outline: none;
      margin: 10px 0;
  }
  .quality-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: #667eea;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
  }
  .slider-explanation {
      font-size: 0.9rem;
      color: #4a5568;
      font-style: italic;
      text-align: center;
      min-height: 2em;
      margin-top: 5px;
  }

  /* Section 8 - Zigzag Scan Styles */
  .interactive-container {
      padding: 10px;
      margin: 1.5rem auto;
      max-width: 320px;
  }
  .zigzag-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      margin: 1.5rem auto;
      max-width: 320px;
  }
  .zigzag-container .canvas-wrapper {
      position: relative;
      width: 280px;
      height: 280px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      overflow: hidden;
  }
  #zigzagCanvas {
      display: block;
      width: 100%;
      height: 100%;
  }
  .play-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 50px;
      font-weight: 700;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
  }
  .play-button:hover {
      transform: translate(-50%, -55%) scale(1.05);
      box-shadow: 0 15px 30px rgba(102, 126, 234, 0.5);
  }
  .play-button.hidden {
      display: none;
      opacity: 0;
      pointer-events: none;
  }
  .stream-container {
      width: 100%;
      max-width: 320px;
      background: #1a202c;
      padding: 15px;
      border-radius: 12px;
      color: #e2e8f0;
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  }
  .stream-label {
      font-size: 0.7rem;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 8px;
      border-bottom: 1px solid #2d3748;
      padding-bottom: 5px;
  }
  .data-stream {
      height: 80px;
      overflow-y: auto;
      line-height: 1.6;
      font-size: 0.9rem;
      padding: 5px;
      scrollbar-width: thin;
      scrollbar-color: #4a5568 #1a202c;
  }
  .data-stream::-webkit-scrollbar {
      width: 6px;
  }
  .data-stream::-webkit-scrollbar-thumb {
      background: #4a5568;
      border-radius: 3px;
  }
  .stream-item {
      display: inline-block;
      margin-right: 8px;
      transition: all 0.2s ease;
  }
  .stream-item.zero {
      color: #4a5568;
  }
  .stream-item.nonzero {
      color: #63b3ed;
      font-weight: bold;
      text-shadow: 0 0 8px rgba(99, 179, 237, 0.3);
  }
  .placeholder-text {
      color: #4a5568;
      font-style: italic;
  }

  @media (max-width: 480px) {
      .zigzag-container .canvas-wrapper {
          width: 300px;
          height: 300px;
      }
      .stat-value {
          font-size: 1.2rem;
      }
  }
</style>
</head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">
<section id="section1" class="visible">
    <img src="images/1.jpg" alt="Pristine photo vs Pixelated photo">
    <h1>Quantization & Artifacts (JPEG Part II)</h1>
    <h2>The Brutal Step</h2>
    <p>Welcome back! In the previous lesson, we transformed our image blocks into frequencies using the DCT. We organized the 'ingredients' of the image, but we haven't actually saved any space yet. We still have 64 numbers for every 8x8 block.</p>
    <div class="continue-button" onclick="showNextSection(2, event)">Continue</div>
</section>

<section id="section2">
    <h2>Making Choices</h2>
    <p>Now comes the brutal part of the process. It is the step where we decide what stays and what goes. It is the step that makes JPEG a <strong>'lossy'</strong> format.</p>
    <div class="continue-button" onclick="showNextSection(3, event)">Continue</div>
</section>

<section id="section3">
    <p>We call this step <strong>Quantization</strong>. It is essentially a strategic rounding-off process.</p>
    <p>The goal is simple: We want to keep the important low-frequency numbers (the general shapes and brightness) precise, but we want to force the high-frequency numbers (the tiny details and noise) to become zero.</p>
    <div class="continue-button" onclick="showNextSection(4, event)">Continue</div>
</section>

<section id="section4">
    <h2>The Math of Loss</h2>
    <p>How do we force numbers to zero? We divide them by large numbers and round the result to the nearest integer.</p>
    <p>Here is the formula used for every single coefficient in the 8x8 block:</p>
    <p>$$ C_{quant}(u, v) = \text{round} \left( \frac{C_{DCT}(u, v)}{Q(u, v)} \right) $$</p>
    <div class="continue-button" onclick="showNextSection(5, event)">Continue</div>
</section>

<section id="section5">
    <p>Let's break this down with a real example. Imagine we have a high-frequency detail in our image‚Äîmaybe the texture of a cat's fur. After DCT, let's say this coefficient (\(C_{DCT}\)) has a value of <strong>42</strong>.</p>
    <p>Now, we look at our <strong>Quantization Table</strong> (\(Q\)). Since this is a high-frequency spot, the algorithm decides it's not very important, so the \(Q\) value is high, let's say <strong>50</strong>.</p>
    <p>We apply the formula:
    $$ \frac{42}{50} = 0.84 $$</p>
    <p>Finally, we round it to the nearest integer:
    $$ \text{round}(0.84) = 0 $$</p>
    <div class="continue-button" onclick="showNextSection(6, event)">Continue</div>
</section>

<section id="section6">
    <p>See that? The detail was 42. But now, it is <strong>0</strong>. That information is gone forever. But on the bright side, writing a '0' takes up way less space than writing '42'.</p>
    <div class="why-it-matters">
        <h3>Why It Matters</h3>
        <p>This rounding to zero is the secret sauce of compression. If we use a lower quality setting, the divisor (50) becomes an even bigger number (like 100), making it even more likely that the result rounds to zero.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(7, event)">Continue</div>
</section>

<section id="section7">
    <h2>The Quantization Slider</h2>
    <p>You've likely seen a 'Quality' slider when saving a JPEG in Photoshop or other software. You are actually controlling that \(Q\) table.</p>
    <div class="interactive-container">
      <div class="stats-bar">
          <div class="stat-item">
              <span class="stat-label">Non-Zero Values</span>
              <span class="stat-value" id="nonZeroCount">64</span>
          </div>
          <div class="stat-item">
              <span class="stat-label">Zeros (Compression)</span>
              <span class="stat-value highlight" id="zeroCount">0</span>
          </div>
      </div>
  
      <canvas id="quantCanvas"></canvas>
  
      <div class="controls-container">
          <div class="slider-labels">
              <span>Low Quality<br><small>(High Compression)</small></span>
              <span id="qualityDisplay" style="font-weight:bold; color:#667eea;">50%</span>
              <span>High Quality<br><small>(Preservation)</small></span>
          </div>
          <input type="range" min="1" max="100" value="50" class="quality-slider" id="qualitySlider">
          <p class="slider-explanation" id="sliderExplanation">
              Adjusting the math...
          </p>
      </div>
  </div>
  
  <script>
  (function() {
      // 1. Data Setup
      // A realistic 8x8 block of DCT coefficients (Raw)
      // Large values in top-left (low freq), small values elsewhere (high freq)
      const rawDCT = [
          [512, -60, 40, 22, -10, 5, 2, 0],
          [42, -28, 15, -8, 4, -2, 1, 0],
          [-18, 12, -6, 4, -1, 0, 0, 0],
          [8, -4, 2, -1, 0, 0, 0, 0],
          [-2, 1, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
      ];
      
      // Let's add some noise to the high frequencies so they aren't all perfectly zero initially
      // to better demonstrate the "cutoff" effect.
      for(let r=0; r<8; r++) {
          for(let c=0; c<8; c++) {
              if(r > 3 || c > 3) {
                  // Add fake noise values like 5, -3, 2, etc.
                  if (rawDCT[r][c] === 0) rawDCT[r][c] = Math.floor(Math.random() * 10) - 5; 
              }
          }
      }
  
      // Standard JPEG Luminance Quantization Table
      const baseQuantMatrix = [
          [16, 11, 10, 16, 24, 40, 51, 61],
          [12, 12, 14, 19, 26, 58, 60, 55],
          [14, 13, 16, 24, 40, 57, 69, 56],
          [14, 17, 22, 29, 51, 87, 80, 62],
          [18, 22, 37, 56, 68, 109, 103, 77],
          [24, 35, 55, 64, 81, 104, 113, 92],
          [49, 64, 78, 87, 103, 121, 120, 101],
          [72, 92, 95, 98, 112, 100, 103, 99]
      ];
  
      // 2. Setup Canvas
      const canvas = document.getElementById('quantCanvas');
      const ctx = canvas.getContext('2d');
      const slider = document.getElementById('qualitySlider');
      const qualityDisplay = document.getElementById('qualityDisplay');
      const zeroCountDisplay = document.getElementById('zeroCount');
      const nonZeroCountDisplay = document.getElementById('nonZeroCount');
      const explanation = document.getElementById('sliderExplanation');
  
      // Handle High DPI displays
      const size = 280;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      ctx.scale(dpr, dpr);
      
      // 3. Logic Functions
      function getJPEGScaleFactor(quality) {
          // Standard JPEG quality scaling formula
          if (quality <= 0) quality = 1;
          if (quality > 100) quality = 100;
          
          if (quality < 50) {
              return 5000 / quality;
          } else {
              return 200 - (2 * quality);
          }
      }
  
      function update() {
          const quality = parseInt(slider.value);
          qualityDisplay.innerText = quality + '%';
          
          // Explain what's happening
          if(quality > 90) {
              explanation.innerText = "Divisors are tiny (mostly 1s). Almost all original data is preserved. File size is large.";
          } else if (quality > 50) {
              explanation.innerText = "Divisors are small. We are rounding off noise, but keeping textures.";
          } else if (quality > 20) {
              explanation.innerText = "Divisors are getting large. High frequency details (bottom-right) are turning into zeros.";
          } else {
              explanation.innerText = "Divisors are huge! We are aggressively rounding everything to zero. Only the basic shapes (top-left) remain.";
          }
  
          const scaleFactor = getJPEGScaleFactor(quality);
          let zeros = 0;
          let nonZeros = 0;
  
          // Clear Canvas
          ctx.clearRect(0, 0, size, size);
          
          // Grid properties
          const cellSize = size / 8;
          
          // Draw
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.font = '600 14px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto';
  
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const x = c * cellSize;
                  const y = r * cellSize;
                  
                  // Calculate Scaled Quantization Value (The Divisor)
                  let qVal = Math.floor((baseQuantMatrix[r][c] * scaleFactor + 50) / 100);
                  if (qVal < 1) qVal = 1; // prevent divide by zero
                  if (qVal > 255) qVal = 255; // cap at byte size usually
                  
                  // Calculate Result (The Data we keep)
                  const dctVal = rawDCT[r][c];
                  const finalVal = Math.round(dctVal / qVal);
  
                  if (finalVal === 0) {
                      zeros++;
                      ctx.fillStyle = '#f8fafc'; // Very light background for zeros
                      ctx.fillRect(x, y, cellSize, cellSize);
                      
                      ctx.fillStyle = '#cbd5e0'; // Faded text color
                      ctx.font = '400 14px -apple-system';
                  } else {
                      nonZeros++;
                      // Highlight the "Important" zone (Low Frequencies)
                      // Visual cue: darker background for larger values
                      ctx.fillStyle = r+c < 4 ? '#eff6ff' : '#ffffff'; 
                      ctx.fillRect(x, y, cellSize, cellSize);
                      
                      ctx.fillStyle = '#2d3748'; // Strong text color
                      ctx.font = '600 14px -apple-system';
                  }
  
                  // Draw Grid Lines (Subtle)
                  ctx.strokeStyle = '#e2e8f0';
                  ctx.lineWidth = 1;
                  ctx.strokeRect(x, y, cellSize, cellSize);
  
                  // Draw Text
                  ctx.fillText(finalVal, x + cellSize/2, y + cellSize/2);
              }
          }
  
          // Highlight the "Zigzag" tail (Bottom Right) if heavily compressed
          // Visual flair: draw a faint red overlay on the bottom right if quality is low
          if(quality < 30) {
              ctx.fillStyle = 'rgba(245, 101, 101, 0.05)';
              ctx.beginPath();
              ctx.moveTo(size, 0);
              ctx.lineTo(size, size);
              ctx.lineTo(0, size);
              ctx.fill();
          }
  
          // Update stats
          zeroCountDisplay.innerText = zeros;
          nonZeroCountDisplay.innerText = nonZeros;
          
    // Color stats based on compression
    if(zeros > 50) {
        zeroCountDisplay.style.color = '#48bb78'; // Green (Good compression)
        zeroCountDisplay.innerHTML = zeros + " <small>(Tiny File!)</small>";
    } else if (zeros > 30) {
        zeroCountDisplay.style.color = '#2d3748';
        zeroCountDisplay.innerText = zeros;
    } else {
        zeroCountDisplay.style.color = '#e53e3e'; // Red (Bad compression)
        zeroCountDisplay.innerText = zeros;
    }
}
  
      // Initialize
      slider.addEventListener('input', update);
      update(); // First draw
  })();
  </script>
    <p>When you slide to 'Low Quality', you are telling the algorithm: "I don't care about details, just give me a small file." The algorithm responds by dividing by huge numbers, turning almost everything into zeros.</p>
    <div class="continue-button" onclick="showNextSection(8, event)">Continue</div>
</section>

<section id="section8">
    <h2>Grouping the Zeros</h2>
    <p>After quantization, our 8x8 block looks very different. The top-left corner has non-zero numbers (the important stuff), but the bottom-right is now a wasteland of zeros.</p>
    <p>Computers love long strings of zeros. It's much more efficient to say "twelve zeros" than "zero, zero, zero...". To maximize this, we don't read the block row-by-row. We read it in a <strong>Zigzag</strong> pattern.</p>
    <div class="zigzag-container">
      <div class="canvas-wrapper">
          <canvas id="zigzagCanvas"></canvas>
          <button id="playZigzagBtn" class="play-button">‚ñ∂ Start Zigzag Scan</button>
      </div>
      
      <div class="stream-container">
          <div class="stream-label">Resulting Data Stream (1D Array):</div>
          <div id="dataStream" class="data-stream">
              <span class="placeholder-text">Press Play to scan...</span>
          </div>
      </div>
  </div>
  
  <script>
  (function() {
      // 1. Data Setup
      // A Quantized Block (mostly zeros at the end)
      const blockData = [
          [26, -3, 1, 0, 0, 0, 0, 0],
          [4, -2, 0, 0, 0, 0, 0, 0],
          [-3, 1, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [1, 0, 0, 0, 0, 0, 0, 0], // One stray detail
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0],
          [0, 0, 0, 0, 0, 0, 0, 0]
      ];
  
      // Pre-calculated Zigzag Path Coordinates [row, col]
      // This is the standard JPEG Zigzag order
      const zigzagPath = [
          [0,0], [0,1], [1,0], [2,0], [1,1], [0,2], [0,3], [1,2],
          [2,1], [3,0], [4,0], [3,1], [2,2], [1,3], [0,4], [0,5],
          [1,4], [2,3], [3,2], [4,1], [5,0], [6,0], [5,1], [4,2],
          [3,3], [2,4], [1,5], [0,6], [0,7], [1,6], [2,5], [3,4],
          [4,3], [5,2], [6,1], [7,0], [7,1], [6,2], [5,3], [4,4],
          [3,5], [2,6], [1,7], [2,7], [3,6], [4,5], [5,4], [6,3],
          [7,2], [7,3], [6,4], [5,5], [4,6], [3,7], [4,7], [5,6],
          [6,5], [7,4], [7,5], [6,6], [5,7], [6,7], [7,6], [7,7]
      ];
  
      // 2. DOM Elements
      const canvas = document.getElementById('zigzagCanvas');
      const ctx = canvas.getContext('2d');
      const btn = document.getElementById('playZigzagBtn');
      const streamDiv = document.getElementById('dataStream');
      
      // High DPI setup
      const size = 280;
      const dpr = window.devicePixelRatio || 1;
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      ctx.scale(dpr, dpr);
  
      // State
      let currentStep = -1;
      let isPlaying = false;
      let animationId = null;
      const cellSize = size / 8;
  
      // 3. Drawing Functions
      function drawGrid() {
          ctx.clearRect(0, 0, size, size);
          
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          
          for (let r = 0; r < 8; r++) {
              for (let c = 0; c < 8; c++) {
                  const x = c * cellSize;
                  const y = r * cellSize;
                  const val = blockData[r][c];
  
                  // Background for cell
                  if(r === 0 && c === 0) ctx.fillStyle = '#e6fffa'; // DC component
                  else if (val === 0) ctx.fillStyle = '#f8fafc';
                  else ctx.fillStyle = '#fff';
                  
                  ctx.fillRect(x, y, cellSize, cellSize);
                  
                  // Borders
                  ctx.strokeStyle = '#e2e8f0';
                  ctx.lineWidth = 1;
                  ctx.strokeRect(x, y, cellSize, cellSize);
                  
                  // Text
                  if(val === 0) {
                      ctx.fillStyle = '#cbd5e0';
                      ctx.font = '400 14px monospace';
                  } else {
                      ctx.fillStyle = '#2d3748';
                      ctx.font = '700 16px monospace';
                  }
                  ctx.fillText(val, x + cellSize/2, y + cellSize/2);
              }
          }
      }
  
      function drawSnake(upToStep) {
          if (upToStep < 0) return;
  
          ctx.beginPath();
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.lineWidth = 4;
          
          // Gradient stroke
          const gradient = ctx.createLinearGradient(0, 0, size, size);
          gradient.addColorStop(0, '#667eea');
          gradient.addColorStop(1, '#764ba2');
          ctx.strokeStyle = gradient;
  
          // Move to start
          const startR = zigzagPath[0][0];
          const startC = zigzagPath[0][1];
          ctx.moveTo(startC * cellSize + cellSize/2, startR * cellSize + cellSize/2);
  
          // Draw lines
          for(let i = 1; i <= upToStep; i++) {
              const r = zigzagPath[i][0];
              const c = zigzagPath[i][1];
              ctx.lineTo(c * cellSize + cellSize/2, r * cellSize + cellSize/2);
          }
          ctx.stroke();
  
          // Draw Head
          const headR = zigzagPath[upToStep][0];
          const headC = zigzagPath[upToStep][1];
          const hx = headC * cellSize + cellSize/2;
          const hy = headR * cellSize + cellSize/2;
          
          ctx.fillStyle = '#764ba2';
          ctx.beginPath();
          ctx.arc(hx, hy, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // Highlight active cell box
          ctx.strokeStyle = '#764ba2';
          ctx.lineWidth = 2;
          ctx.strokeRect(headC * cellSize + 2, headR * cellSize + 2, cellSize - 4, cellSize - 4);
      }
  
      function updateStream(step) {
          if(step === 0) streamDiv.innerHTML = ''; // Clear placeholder
          
          const r = zigzagPath[step][0];
          const c = zigzagPath[step][1];
          const val = blockData[r][c];
          
          const span = document.createElement('span');
          span.className = 'stream-item ' + (val === 0 ? 'zero' : 'nonzero');
          span.innerText = val + ', ';
          
          // Auto-scroll
          streamDiv.appendChild(span);
          streamDiv.scrollTop = streamDiv.scrollHeight;
      }
  
      // 4. Animation Loop
      let lastTime = 0;
      const stepDelay = 80; // ms per step
  
      function loop(timestamp) {
          if (!isPlaying) return;
  
          if (!lastTime) lastTime = timestamp;
          const elapsed = timestamp - lastTime;
  
          if (elapsed > stepDelay) {
              currentStep++;
              lastTime = timestamp;
  
              drawGrid();
              drawSnake(currentStep);
              updateStream(currentStep);
  
              if (currentStep >= 63) {
                  isPlaying = false;
                  btn.innerText = "‚Ü∫ Replay Scan";
                  btn.classList.remove('hidden');
                  
                  // Add EOB marker
                  const eob = document.createElement('span');
                  eob.innerText = 'EOB';
                  eob.style.color = '#e53e3e';
                  eob.style.fontWeight = 'bold';
                  streamDiv.appendChild(eob);
                  
                  return;
              }
          }
          animationId = requestAnimationFrame(loop);
      }
  
      // 5. Init & Event Listeners
      drawGrid(); // Initial Static Draw
  
      btn.addEventListener('click', () => {
          // Reset
          currentStep = -1;
          isPlaying = true;
          btn.classList.add('hidden');
          streamDiv.innerHTML = ''; // Clear stream
          lastTime = 0;
          
          if (animationId) cancelAnimationFrame(animationId);
          animationId = requestAnimationFrame(loop);
      });
  
  })();
  </script>
    <p>This "Zigzag Scan" organizes the data so that all the zeros are grouped together at the end of the list, making the file size incredibly tiny.</p>
    <div class="continue-button" onclick="showNextSection(9, event)">Continue</div>
</section>

<section id="section9">
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>Why does the Zigzag scan start at the top-left and move to the bottom-right?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'While it does look cool, that is not the engineering reason!')">It looks cooler than reading row-by-row.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'JPEG is not about encryption; it is about compression.')">To mix up the data for encryption.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Exactly! The top-left has the large values, and the bottom-right is mostly zeros after quantization. The zigzag groups them for efficient encoding.')">To group significant low-frequency coefficients first and zeros last.</div>
        </div>
    </div>
    <div class="continue-button" id="continue-after-quiz" onclick="showNextSection(10, event)" style="display: none;">Continue</div>
</section>

<section id="section10">
    <h2>When It Goes Wrong: Artifacts</h2>
    <p>We've talked about throwing away data. Usually, our eyes don't notice. But if we are too aggressive‚Äîif we set that Quality slider too low‚Äîthe cracks start to show. These visual errors are called <strong>Compression Artifacts</strong>.</p>
    <p>The most common one is <strong>Blocking</strong>. Remember how we chop the image into independent 8x8 blocks? If we compress too hard, the boundaries between these blocks become visible.</p>
    <img src="images/2.jpg" alt="Blue sky with blocking artifacts">
    <p>Another common issue is <strong>Ringing</strong> or "Mosquito Noise". This looks like fuzzy dirt buzzing around sharp edges, like text or high-contrast lines. It happens because we deleted the high-frequencies needed to draw a sharp, clean line.</p>
    <p>You've definitely seen this online. In fact, it's become a style of its own.</p>
    <img src="images/3.jpg" alt="Deep fried meme">
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Quantization</h4>
        <p>The process of constraining a large set of values (coefficients) to a discrete set (integers) by dividing and rounding. This is the primary source of information loss in JPEG.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(11, event)">Continue</div>
</section>

<section id="section11">
    <h2>Can We Go Back?</h2>
    <div class="faq-section">
        <h3>Frequently Asked Question</h3>
        <h4>Can I reverse the quantization to get the original picture back?</h4>
        <p><strong>Answer:</strong> No. This is the definition of 'Lossy'. Look at our math example again: We had 42, divided by 50, and rounded to 0. If I give you the number 0 and tell you 'I divided X by 50 to get this', X could have been 10, 20, or 42. You can never know for sure. The data is lost.</p>
    </div>
    <p>This is why you should never edit and re-save a JPEG repeatedly. Every time you save, you run the quantization step again, and you lose more data. It's like making a photocopy of a photocopy.</p>
    <div class="check-your-knowledge">
        <h3>Stop and Think</h3>
        <h4>If you were designing a compression system for a medical X-ray machine, would you use Quantization?</h4>
        <div id="stop-think-answer" style="display:none;" class="animate-in">
            <strong>Answer:</strong> Probably not! Or you would use very gentle quantization. In medical imaging, a tiny "high frequency" detail might be a micro-fracture in a bone. Rounding that to zero could lead to a misdiagnosis.
        </div>
        <button class="reveal-button" onclick="revealAnswer('stop-think-answer')">Reveal Answer</button>
    </div>
    <div class="continue-button" onclick="showNextSection(12, event)">Continue</div>
</section>

<section id="section12">
    <h2>Review and Reflect</h2>
    <p>You have survived the most mathematical and destructive part of image compression.</p>
    
    <p>In this lesson, we learned that:</p>
    <ul>
        <li><strong>Quantization</strong> is the step where we divide DCT coefficients and round them to integers.</li>
        <li>This is where <strong>data loss</strong> happens; we sacrifice high-frequency details to save space.</li>
        <li>The <strong>Zigzag scan</strong> organizes the resulting zeros to make the file size even smaller.</li>
        <li>Over-compression leads to visible <strong>artifacts</strong> like blocking and ringing.</li>
    </ul>
    <p>In the next and final lesson of this chapter, we will zoom out and look at the entire pipeline from the camera lens to the final file, putting all these pieces together.</p>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">‚úì Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 12;

updateProgress();
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId, event) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event ? event.target : (window.event ? window.event.target : null);
    if (!nextSectionElement) return;
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    setTimeout(() => { nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
    
    // Only show continue button if answer is correct
    if (!isCorrect) return;
    
    // Logic for section 9 (Quiz)
    const parentSection = element.closest('section');
    if (parentSection && parentSection.id === 'section9') {
        const continueButton = document.getElementById('continue-after-quiz');
        if (continueButton && continueButton.style.display === 'none') {
            setTimeout(() => {
                continueButton.style.display = 'block';
                continueButton.classList.add('show-with-animation');
            }, 800);
        }
    }
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // Default placeholders - typically overwritten by actual LMS logic
                let courseId = 'computer-vision';
                let pathId = 'fourier-transform-images';
                let moduleId = 'cv-ch06-l4-jpeg-part2';
                let lessonId = 'cv-ch06-l4-main';
                
                if (window.parent.currentRoute) {
                    const route = window.parent.currentRoute;
                    if (route.courseId) courseId = route.courseId;
                    if (route.pathId) pathId = route.pathId;
                    if (route.moduleId) moduleId = route.moduleId;
                    if (route.lessonId) lessonId = route.lessonId;
                }
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('course')) courseId = urlParams.get('course');
                if (urlParams.get('path')) pathId = urlParams.get('path');
                if (urlParams.get('module')) moduleId = urlParams.get('module');
                if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = '‚úÖ Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv-ch06-l4-main_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['üéâ', 'üéä', '‚ú®', 'üåü', 'üíæ', 'üñºÔ∏è', 'üìâ', 'üëè'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = '‚óè';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = 'üéâ Lesson Completed! Great Job! üéâ';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    // Check local storage for basic persistence
    const isCompleted = localStorage.getItem('lesson_cv-ch06-l4-main_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = '‚úÖ Completed!';
    }
});
</script>
</body>
</html>





