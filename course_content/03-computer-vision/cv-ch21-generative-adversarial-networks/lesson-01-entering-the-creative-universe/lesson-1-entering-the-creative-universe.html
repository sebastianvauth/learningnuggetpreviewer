<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<link rel="stylesheet" href="../../styles/lesson.css">
<title>Entering the Creative Universe</title>
<script>
window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">

<section id="section1" class="visible">
    <div class="image-placeholder">
        <img src="images/1.jpg" alt="Split-screen showing a classifier labeling an image versus a generator synthesizing one from noise." loading="lazy">
    </div>
    <h1>The Creative Universe</h1>

    <p>Welcome to the 'Creative Universe.' Throughout your journey in deep learning so far, we have primarily navigated what can be called the "engineering universe." We've focused on solving well-defined problems: classifying an image, detecting an object, or segmenting a scene. In those tasks, we acted as analysts, dissecting data that already existed. Today, we become artists.</p>
    <div class="continue-button" onclick="showNextSection(2)">Continue</div>
</section>

<section id="section2">
    <h2>A Fundamental Shift</h2>
    <p>We are venturing into a realm where the goal is not to analyze existing data, but to generate new, synthetic data that is indistinguishable from reality.</p>
    <div class="continue-button" onclick="showNextSection(3)">Continue</div>
</section>

<section id="section3">
    <p>In the Engineering Universe, we ask: "What is this?" In the Creative Universe, we ask: "Can you make this?"</p>
    <p>This isn't just a change in function; it's a fundamental shift in how we ask neural networks to understand the world.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Discriminative Modeling</h4>
        <p>A type of modeling where the goal is to discriminate between different classes of data. It learns the conditional probability distribution \(p(y|x)\), which represents the probability of a label \(y\) given an input \(x\).</p>
    </div>
    <p>Discriminative models are what you are likely most familiar with: classifiers and regressors. They draw lines in the sand to separate cats from dogs.</p>
    <div class="continue-button" onclick="showNextSection(4)">Continue</div>
</section>

<section id="section4">
    <p>But what if we don't want a label? What if we want the data itself?</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Generative Modeling</h4>
        <p>A type of modeling where the goal is to learn the distribution of the data itself. It attempts to learn how the data is generated, often modeled as sampling from a probability distribution \(p(x)\).</p>
    </div>
    <p>Generative models don't just look at the sand; they learn how to build the beach. They learn the underlying structure of the data so they can create new samples that look like they belong in the original dataset.</p>

    <div class="continue-button" onclick="showNextSection(5)">Continue</div>
</section>

<section id="section5">
    <p>Let's test your intuition on this distinction immediately.</p>
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>If a neural network analyzes a photo of a street scene and outputs a probability map telling you that a specific pixel is 90% likely to be part of a 'car', is this model generative or discriminative?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Not quite. The model is taking existing data (the photo) and assigning a label or probability to it. It isn\'t creating new data; it is discriminating between classes (car vs. background).')">Generative</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Spot on. The model is calculating \\(p(y|x)\\)—the probability of the label \'car\' given the pixel data. It is analyzing, not creating.')">Discriminative</div>
        </div>
    </div>
    <div class="continue-button" id="continue-after-s5" onclick="showNextSection(6)" style="display: none;">Continue</div>
</section>

<section id="section6">
    <h2>Mapping the Stars</h2>
    <p>To understand this difference visually, imagine our data points—images of cats, for example—are stars in a galaxy.</p>
    <!-- INTERACTIVE COMPONENT START -->
<div class="interactive-container" id="ganInteractive">
  <div class="interactive-controls">
      <button class="mode-btn active" onclick="setMode('discriminative')">Mode 1: Discriminative</button>
      <button class="mode-btn" onclick="setMode('generative')">Mode 2: Generative</button>
  </div>

  <canvas id="dataCanvas" width="600" height="350"></canvas>
  
  <div class="feedback-bar-container" id="feedbackContainer">
      <div class="feedback-bar" id="feedbackBar"></div>
  </div>
  
  <p class="instruction-text" id="instructionText">Draw a line to separate the Blue dots from the Red dots.</p>

  <script>
      // --- Configuration ---
      const canvas = document.getElementById('dataCanvas');
      const ctx = canvas.getContext('2d');
      const instructions = document.getElementById('instructionText');
      const feedbackContainer = document.getElementById('feedbackContainer');
      const feedbackBar = document.getElementById('feedbackBar');
      
      // State
      let mode = 'discriminative'; // 'discriminative' | 'generative'
      let blueDots = [];
      let redDots = [];
      let line = { start: null, end: null, isDrawing: false };
      let cloud = { x: 300, y: 175, radius: 60, isDragging: false, isResizing: false };
      
      // --- Initialization ---
      function initData() {
          blueDots = createCluster(150, 200, 40, 40); // Left-ish cluster
          redDots = createCluster(450, 150, 40, 40);  // Right-ish cluster
      }

      function createCluster(centerX, centerY, spread, count) {
          let dots = [];
          for (let i = 0; i < count; i++) {
              // Box-Muller transform for simple Gaussian distribution
              let u = 0, v = 0;
              while(u === 0) u = Math.random(); 
              while(v === 0) v = Math.random();
              let num = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
              
              dots.push({
                  x: centerX + num * spread,
                  y: centerY + (Math.random() - 0.5) * spread * 2 // Looser Y spread
              });
          }
          return dots;
      }

      // --- Interaction Logic ---
      function setMode(newMode) {
          mode = newMode;
          
          // UI Updates
          document.querySelectorAll('.mode-btn').forEach(btn => {
              btn.classList.toggle('active', btn.innerText.toLowerCase().includes(mode));
          });
          
          // Reset Interaction States
          line = { start: null, end: null, isDrawing: false };
          cloud = { x: 300, y: 175, radius: 70, isDragging: false, isResizing: false };

          if (mode === 'discriminative') {
              instructions.innerText = "Click and drag to draw a line separating the Blue and Red dots.";
              feedbackContainer.style.display = 'none';
          } else {
              instructions.innerText = "Drag the center to move the cloud. Drag the edge to resize. Cover the Blue dots!";
              feedbackContainer.style.display = 'block';
              updateGenerativeScore();
          }
          
          draw();
      }

      // Mouse/Touch Events
      function getPos(e) {
          const rect = canvas.getBoundingClientRect();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          return {
              x: (clientX - rect.left) * (canvas.width / rect.width),
              y: (clientY - rect.top) * (canvas.height / rect.height)
          };
      }

      canvas.addEventListener('mousedown', handleStart);
      canvas.addEventListener('touchstart', handleStart, {passive: false});

      canvas.addEventListener('mousemove', handleMove);
      canvas.addEventListener('touchmove', handleMove, {passive: false});

      canvas.addEventListener('mouseup', handleEnd);
      canvas.addEventListener('touchend', handleEnd);

      function handleStart(e) {
          if(e.type === 'touchstart') e.preventDefault(); // Prevent scroll
          const pos = getPos(e);

          if (mode === 'discriminative') {
              line.start = pos;
              line.end = pos;
              line.isDrawing = true;
          } else {
              // Generative Check: Center or Edge?
              const dist = Math.sqrt(Math.pow(pos.x - cloud.x, 2) + Math.pow(pos.y - cloud.y, 2));
              if (Math.abs(dist - cloud.radius) < 15) {
                  cloud.isResizing = true;
              } else if (dist < cloud.radius) {
                  cloud.isDragging = true;
              }
          }
          draw();
      }

      function handleMove(e) {
          if(e.type === 'touchmove') e.preventDefault();
          if (mode === 'discriminative') {
              if (!line.isDrawing) return;
              line.end = getPos(e);
          } else {
              const pos = getPos(e);
              // Cursor logic
              const dist = Math.sqrt(Math.pow(pos.x - cloud.x, 2) + Math.pow(pos.y - cloud.y, 2));
              canvas.style.cursor = (Math.abs(dist - cloud.radius) < 10) ? 'nwse-resize' : (dist < cloud.radius ? 'move' : 'default');

              if (cloud.isDragging) {
                  cloud.x = pos.x;
                  cloud.y = pos.y;
                  updateGenerativeScore();
              } else if (cloud.isResizing) {
                  cloud.radius = Math.max(20, dist);
                  updateGenerativeScore();
              }
          }
          draw();
      }

      function handleEnd() {
          if (mode === 'discriminative' && line.isDrawing) {
              checkDiscriminativeScore();
          }
          line.isDrawing = false;
          cloud.isDragging = false;
          cloud.isResizing = false;
          draw();
      }

      // --- Math & Scoring ---

      function checkDiscriminativeScore() {
          if (!line.start || !line.end) return;
          
          // Line vector math to determine "left" or "right" of line
          const v1 = { x: line.end.x - line.start.x, y: line.end.y - line.start.y };
          
          let blueSide = 0; 
          let redSide = 0;

          // Helper: Cross product 2D (determinant)
          const isLeft = (p0, p1, p2) => {
              return ((p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x));
          }

          // Check where Blue dots lie
          let bluePosCount = 0;
          blueDots.forEach(d => {
              if (isLeft(line.start, line.end, d) > 0) bluePosCount++;
          });
          const blueMainlyLeft = bluePosCount > (blueDots.length / 2);

          // Check correctness
          let correct = 0;
          let total = blueDots.length + redDots.length;

          blueDots.forEach(d => {
              const left = isLeft(line.start, line.end, d) > 0;
              if (left === blueMainlyLeft) correct++;
          });

          redDots.forEach(d => {
              const left = isLeft(line.start, line.end, d) > 0;
              if (left !== blueMainlyLeft) correct++; // Should be on opposite side
          });

          const accuracy = correct / total;
          
          if (accuracy > 0.95) {
              instructions.innerHTML = `<span style="color:#38a169; font-weight:bold">Perfect separation! You acted as a Discriminator.</span>`;
          } else if (accuracy > 0.8) {
              instructions.innerText = "Good job! You separated most of the data.";
          } else {
              instructions.innerText = "Try again. Draw a line BETWEEN the clusters.";
          }
      }

      function updateGenerativeScore() {
          let covered = 0;
          blueDots.forEach(d => {
              const dist = Math.sqrt(Math.pow(d.x - cloud.x, 2) + Math.pow(d.y - cloud.y, 2));
              if (dist <= cloud.radius) covered++;
          });

          // Score logic: Reward covering dots, penalize empty space (too big)
          const coveragePct = covered / blueDots.length;
          const areaPenalty = Math.max(0, (cloud.radius - 80) / 200); // Simple penalty if huge
          let score = Math.max(0, Math.min(100, (coveragePct - areaPenalty) * 100));
          
          feedbackBar.style.width = `${score}%`;
          
          // Color based on score
          if (score > 80) {
              feedbackBar.style.background = '#38a169'; // Green
              instructions.innerHTML = `<span style="color:#38a169; font-weight:bold">Excellent! You captured the distribution.</span>`;
          } else if (score > 50) {
              feedbackBar.style.background = '#ecc94b'; // Yellow
              instructions.innerText = "Getting closer. Try to cover all Blue dots tightly.";
          } else {
              feedbackBar.style.background = '#e53e3e'; // Red
              instructions.innerText = "Drag the cloud over the Blue dots.";
          }
      }

      // --- Rendering ---
      function draw() {
          // Clear
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw Blue Dots (Real Data)
          ctx.fillStyle = "#4299e1";
          blueDots.forEach(d => {
              ctx.beginPath();
              ctx.arc(d.x, d.y, 4, 0, Math.PI * 2);
              ctx.fill();
          });

          // Draw Red Dots (Fake/Noise) - Only in Discriminative Mode
          if (mode === 'discriminative') {
              ctx.fillStyle = "#f56565";
              redDots.forEach(d => {
                  ctx.beginPath();
                  ctx.arc(d.x, d.y, 4, 0, Math.PI * 2);
                  ctx.fill();
              });

              // Draw Line
              if (line.start && line.end) {
                  ctx.strokeStyle = "#2d3748";
                  ctx.lineWidth = 3;
                  ctx.setLineDash([5, 5]);
                  ctx.beginPath();
                  ctx.moveTo(line.start.x, line.start.y);
                  ctx.lineTo(line.end.x, line.end.y);
                  ctx.stroke();
                  ctx.setLineDash([]);
              }
          } 
          else {
              // Generative Mode: Draw Cloud
              ctx.fillStyle = "rgba(66, 153, 225, 0.2)"; // Transparent Blue
              ctx.strokeStyle = "#4299e1";
              ctx.lineWidth = 2;
              
              ctx.beginPath();
              ctx.arc(cloud.x, cloud.y, cloud.radius, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();

              // Draw Center Handle
              ctx.fillStyle = "white";
              ctx.beginPath();
              ctx.arc(cloud.x, cloud.y, 5, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();

              // Draw Resize Handle (Right edge)
              ctx.fillStyle = "white";
              ctx.beginPath();
              ctx.arc(cloud.x + cloud.radius, cloud.y, 6, 0, Math.PI * 2);
              ctx.fill();
              ctx.stroke();
          }
      }

      // Boot
      initData();
      draw();
  </script>
</div>
<!-- INTERACTIVE COMPONENT END -->
    <p>In the interactive above, try out the two roles. In 'Discriminative' mode, your job is to separate the blue data from the red data. In 'Generative' mode, your job is to shape the cloud to match the blue data exactly.</p>
    <div class="continue-button" onclick="showNextSection(7)">Continue</div>
</section>

<section id="section7">
    <p>Notice the difference? In the first mode, you only care about the <em>boundary</em>. As long as the line separates the groups, it's a good model. You don't need to know where exactly the blue dots are, just that they are on 'that side' of the line.</p>
    <div class="continue-button" onclick="showNextSection(8)">Continue</div>
</section>

<section id="section8">
    <p>In the second mode, you have to understand the <em>shape</em> of the blue cluster. You are learning the distribution. Once your cloud matches the blue dots, you can close your eyes, point to a random spot inside your cloud, and you will likely hit a valid data point.</p>
    <p>This is exactly what a Generative Adversarial Network (GAN) does: it learns to map this cloud so we can pick a random point from it and turn it into an image.</p>
    <div class="continue-button" onclick="showNextSection(9)">Continue</div>
</section>

<section id="section9">
    <h2>The Challenge of Creation</h2>
    <p>It might seem like drawing a cloud is easier than drawing a specific line, but in high-dimensional space (like images), generation is incredibly difficult.</p>
    <div class="check-your-knowledge">
        <h3>Stop and Think</h3>
        <h4>Why might generating a realistic image be harder for a computer than classifying one?</h4>
        <div id="cuy-challenge-answer" style="display:none;" class="animate-in"><strong>Answer:</strong> Think about the information required. To classify a cat, the model just needs to find whiskers or pointed ears. To <em>generate</em> a cat, it needs to know exactly where every single pixel goes, the texture of the fur, the lighting, the anatomy, and how those pixels relate to each other to form a coherent whole.</div>
        <button class="reveal-button" onclick="revealAnswer('cuy-challenge-answer')">Reveal Answer</button>
    </div>
    <div class="continue-button" onclick="showNextSection(10)">Continue</div>
</section>

<section id="section10">
    <p>Exactly. A classifier can ignore the background, the lighting, or the color of the cat's eyes as long as it sees 'cat-like' features. A generative model cannot ignore anything. If it gets the lighting wrong, the image looks fake. If it gets the anatomy wrong, it looks like a nightmare.</p>
    <div class="why-it-matters">
        <h3>Why It Matters</h3>
        <p>This technology is the foundation for the AI revolution you see in the news. Tools like Midjourney, DALL-E, and even ChatGPT are generative models. They haven't just memorized data; they have learned the structure of reality (or language) well enough to create new instances of it.</p>
    </div>

    <div class="continue-button" onclick="showNextSection(11)">Continue</div>
</section>

<section id="section11">
    <h2>Test Your Intuition</h2>
    <p>Before we dive into the mechanics of how we actually build these models in the next lesson, let's make sure you have a solid grasp of the philosophy.</p>
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>Which of the following scenarios describes a Generative Model?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'This is a classic discriminative task. It is classifying transactions based on a boundary.')">A system that detects credit card fraud by drawing a boundary between 'normal' and 'suspicious' transactions.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'This is regression, which is a form of discriminative modeling (predicting a value \\(y\\) given history \\(x\\)).')">A system that predicts the future price of a stock based on past performance.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! The system is creating new data samples (sneaker designs) that follow the distribution of the training data.')">A system that produces new designs for sneakers by studying a database of existing fashion trends.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'This is classification: mapping input \\(x\\) (audio) to label \\(y\\) (genre).')">A system that identifies the genre of a song from its audio waveform.</div>
        </div>
    </div>
    <div class="continue-button" id="continue-after-s11" onclick="showNextSection(12)" style="display: none;">Continue</div>
</section>

<section id="section12">
    <h3>Frequently Asked Questions</h3>
    <h4>Does a generative model just copy the images it has seen?</h4>
    <p>No, that would be 'overfitting' or memorization. A good generative model learns the <em>rules</em> or the <em>probability distribution</em> of the data. Just like you know what a dog looks like and can sketch a dog you've never seen before, the model learns the 'concept' of the data to create entirely new, unique samples.</p>
    <div class="continue-button" onclick="showNextSection(13)">Continue</div>
</section>

<section id="section13">
    <h2>Review and Reflect</h2>
    <p>You have now stepped into the Creative Universe.</p>
    <p>In this lesson, we established the difference between the two main families of deep learning:</p>
    <ul>
        <li><strong>Discriminative Models</strong> (\(p(y|x)\)): The Engineers. They draw boundaries to classify or regress data. They ask "What is this?"</li>
        <li><strong>Generative Models</strong> (\(p(x)\)): The Artists. They learn the distribution of data to sample new creations. They ask "Can I make this?"</li>
    </ul>
    <p>We visualized this difference by comparing drawing a decision boundary line versus mapping a data cloud. In the next lesson, we will introduce the specific architecture that allows computers to master this creative process: the Generative Adversarial Network (GAN).</p>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">✓ Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 13;

updateProgress();
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event && event.target;
    if (!nextSectionElement) return;
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    setTimeout(() => { nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
    
    // Only show continue button if answer is correct
    if (!isCorrect) return;
    
    // Re-trigger MathJax to render math in the explanation
    if (window.MathJax) {
        window.MathJax.typesetPromise([explanationDiv]).catch(function (err) { console.log('MathJax Error:', err); });
    }

    // Logic to show continue button after interaction
    const parentSection = element.closest('section');
    if (parentSection && (parentSection.id === 'section5' || parentSection.id === 'section11')) {
        const continueButton = document.getElementById(parentSection.id === 'section5' ? 'continue-after-s5' : 'continue-after-s11');
        if (continueButton && continueButton.style.display === 'none') {
            setTimeout(() => {
                continueButton.style.display = 'block';
                continueButton.classList.add('show-with-animation');
            }, 800);
        }
    }
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // Placeholder IDs - to be updated by LMS context
                let courseId = 'computer-vision';
                let pathId = 'generative-adversarial-networks';
                let moduleId = 'cv-ch21-m1-foundations';
                let lessonId = 'cv-ch21-l2-entering-creative-universe';
                if (window.parent.currentRoute) {
                    const route = window.parent.currentRoute;
                    if (route.courseId) courseId = route.courseId;
                    if (route.pathId) pathId = route.pathId;
                    if (route.moduleId) moduleId = route.moduleId;
                    if (route.lessonId) lessonId = route.lessonId;
                }
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('course')) courseId = urlParams.get('course');
                if (urlParams.get('path')) pathId = urlParams.get('path');
                if (urlParams.get('module')) moduleId = urlParams.get('module');
                if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = '✅ Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv-ch21-m1-l2_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['🎉', '🎊', '✨', '🌟', '🎈', '🏆', '👏', '🥳'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = '●';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = '🎉 Lesson Completed! Great Job! 🎉';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    // Logic to check completion status from Parent or LocalStorage
    if (window.parent && window.parent.ProgressTracker) {
         // Same ID logic as above
        let courseId = 'computer-vision';
        let pathId = 'generative-adversarial-networks';
        let moduleId = 'cv-ch21-m1-foundations';
        let lessonId = 'cv-ch21-l2-entering-creative-universe';
        if (window.parent.currentRoute) {
            const route = window.parent.currentRoute;
            if (route.courseId) courseId = route.courseId;
            if (route.pathId) pathId = route.pathId;
            if (route.moduleId) moduleId = route.moduleId;
            if (route.lessonId) lessonId = route.lessonId;
        }
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('course')) courseId = urlParams.get('course');
        if (urlParams.get('path')) pathId = urlParams.get('path');
        if (urlParams.get('module')) moduleId = urlParams.get('module');
        if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
        
        try {
            const progress = window.parent.ProgressTracker.getLessonProgress(courseId, pathId, moduleId, lessonId);
            if (progress && progress.state === window.parent.ProgressTracker.STATES.COMPLETED) {
                button.classList.add('completed');
                button.innerHTML = '✅ Completed!';
                return;
            }
        } catch(e) { console.log("Tracker error", e); }
    }
    const isCompleted = localStorage.getItem('lesson_cv-ch21-m1-l2_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = '✅ Completed!';
    }
});
</script>
</body>
</html>