{
    "lesson": {
      "title": "Lesson 2: The Rigid World: Translation, Rotation, & Scaling",
      "sections": [
        {
          "title": "Intro Section",
          "content": "# The Rigid World: Translation, Rotation, & Scaling",
          "image": "Description: A comic strip in three panels. Panel 1: A character (representing an image) stands still with the label 'Original'. Panel 2: The same character has slid to the right, with an arrow showing the movement and the label 'Translation'. Panel 3: The character is now spinning and has grown larger, with swirl and expansion lines, labeled 'Rotation & Scaling'.",
          "text": "Now that we have our new superpower—homogeneous coordinates—let's put it to work! In the real world, objects move. They slide across tables, spin in the air, and appear bigger or smaller as they move closer or further away. We're going to learn how to describe these 'rigid' movements mathematically, just like animating a character in a video game. We'll learn to slide, spin, and resize objects, all using the power of a single matrix."
        },
        {
          "title": "The Simplest Move: Translation",
          "content": "Let's start with the most basic movement: a simple shift, or **translation**. Imagine you want to move every single point in an image 50 pixels to the right and 30 pixels down. You're not changing its size or orientation, just its position.",
          "continueButton": true,
          "additionalContent": [
            {
              "text": "With our new coordinate system, this is incredibly easy. We can build a special 3x3 matrix, called a **translation matrix**, that does this for us.",
              "continueButton": true
            },
            {
              "title": "The Translation Matrix",
              "content": "To translate a point by $(t_x, t_y)$, we use the following matrix, $\\mathbf{M}_{trans}$:",
              "math": "\\mathbf{M}_{trans} = \\begin{pmatrix} 1 & 0 & t_x \\\\ 0 & 1 & t_y \\\\ 0 & 0 & 1 \\end{pmatrix}",
              "text": "Notice how it's almost an identity matrix, but with our desired shifts, $t_x$ and $t_y$, tucked into the last column. Now let's see what happens when we multiply this matrix by a point's homogeneous coordinates.",
              "continueButton": true
            },
            {
              "title": "Example Calculation: Shifting a Point",
              "content": "Let's take a point at $(10, 20)$ and shift it by $(50, 30)$. First, we write our point in homogeneous coordinates: $(10, 20, 1)^T$.",
              "math": "\\begin{pmatrix} 1 & 0 & 50 \\\\ 0 & 1 & 30 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ 20 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} (1 \\cdot 10) + (0 \\cdot 20) + (50 \\cdot 1) \\\\ (0 \\cdot 10) + (1 \\cdot 20) + (30 \\cdot 1) \\\\ (0 \\cdot 10) + (0 \\cdot 20) + (1 \\cdot 1) \\end{pmatrix} = \\begin{pmatrix} 60 \\\\ 50 \\\\ 1 \\end{pmatrix}",
              "text": "The result is $(60, 50, 1)^T$. After back projection, we get the point $(60, 50)$. It worked perfectly! The point moved exactly as we wanted. A translation preserves all lengths and angles; the object just moves.",
              "continueButton": true
            },
            {
              "title": "Adding a Spin: Euclidean Transformation",
              "content": "Okay, shifting is cool, but what about rotating? A movement that combines **rotation** and **translation** is called a **Euclidean transformation**. It's the definition of a 'rigid' motion, like picking up a book and moving it to another shelf without bending or stretching it.",
              "continueButton": true
            },
            {
              "title": "The Euclidean Matrix",
              "content": "To rotate by an angle $\\theta$ and translate by $(t_x, t_y)$, we use this matrix:",
              "math": "\\mathbf{M}_{euc} = \\begin{pmatrix} \\cos \\theta & -\\sin \\theta & t_x \\\\ \\sin \\theta & \\cos \\theta & t_y \\\\ 0 & 0 & 1 \\end{pmatrix}",
              "text": "The top-left 2x2 part is the **Rotation Matrix**, $\\mathbf{R}$. The last column is still our translation vector, $\\mathbf{t}$. We often write this compactly as $\\begin{pmatrix} \\mathbf{R} & \\mathbf{t} \\\\ \\mathbf{0}^T & 1 \\end{pmatrix}$. A Euclidean transformation preserves lengths and angles, just like a pure translation.",
              "continueButton": true
            },
            {
              "title": "Scaling Up: Similarity Transformation",
              "content": "What if we want to make our object bigger or smaller, like when it moves closer or farther away? We can add a uniform scaling factor, `s`, to our Euclidean transform. This is called a **Similarity transformation**.",
              "math": "\\mathbf{M}_{sim} = \\begin{pmatrix} s \\cdot \\cos \\theta & -s \\cdot \\sin \\theta & t_x \\\\ s \\cdot \\sin \\theta & s \\cdot \\cos \\theta & t_y \\\\ 0 & 0 & 1 \\end{pmatrix}",
              "text": "A similarity transformation preserves angles (so a square will still be a square after the transform), but it does *not* preserve lengths (the square will change size).",
              "interactive": {
                "title": "Interactive Element: Transformation Playground",
                "description": "An image of a simple cartoon car is displayed on a 2D grid. To the side, there are three sets of sliders: 1) **Translation:** Sliders for `tx` and `ty`. 2) **Rotation:** A circular dial for the angle `θ`. 3) **Scale:** A slider for `s`. As the user adjusts the sliders, the car image transforms in real-time. Below the image, the corresponding 3x3 transformation matrix updates dynamically, with the `tx`, `ty`, `cos(θ)`, `sin(θ)`, and `s` values changing. This directly links the numbers in the matrix to the visual effect on the car."
              },
              "buildYourVocab": [
                {
                  "term": "Translation",
                  "definition": "A transformation that shifts every point by the same distance in the same direction."
                },
                {
                  "term": "Euclidean Transformation",
                  "definition": "A rigid motion (rotation + translation) that preserves both lengths and angles."
                },
                {
                  "term": "Similarity Transformation",
                  "definition": "A Euclidean transform plus uniform scaling. It preserves angles but not lengths."
                },
                {
                  "term": "Rotation Matrix (R)",
                  "definition": "The 2x2 sub-matrix within a Euclidean or Similarity matrix that performs the rotation."
                }
              ],
              "textAfterVocab": "You can now describe any rigid motion of an object in 2D space!",
              "continueButton": true
            },
            {
              "whyItMatters": {
                "title": "Why does this matter?",
                "text": "These transformations are the absolute foundation of robotics, 2D animation, and object tracking. When a robot arm needs to move to a specific position and orientation, its computer is calculating a Euclidean transformation. When your phone tracks a face to apply a filter, it's constantly estimating the similarity transform between a standard face model and what it sees in the camera."
              },
              "checkYourUnderstanding": {
                "question": "If you apply a Euclidean transformation to a square, will it still be a square of the same size? What about after a Similarity transform?",
                "answer": "After a Euclidean transform, it will be a square of the exact same size. After a Similarity transform, it will still be a perfect square, but it might be bigger or smaller."
              },
              "frequentlyAsked": {
                "question": "What's the difference between a Euclidean and a Rigid Body transformation?",
                "answer": "They are exactly the same thing! 'Rigid Body' is a term often used in physics and robotics because it describes how a solid, non-bending object moves. 'Euclidean' is the term from geometry that describes the properties that are preserved. They are two names for the same concept."
              },
              "testYourKnowledge": {
                "question": "You want to rotate an object, move it to the right, and make it twice as large. Which is the *simplest* class of transformation you can use to do this in one step?",
                "options": [
                  {
                    "option": "Translation",
                    "explanation": "Translation only allows for shifting, not rotation or scaling.",
                    "correct": false
                  },
                  {
                    "option": "Euclidean",
                    "explanation": "A Euclidean transform can rotate and translate, but it can't change the size.",
                    "correct": false
                  },
                  {
                    "option": "Similarity",
                    "explanation": "Correct! A Similarity transform combines rotation, translation, and uniform scaling all in one matrix.",
                    "correct": true
                  },
                  {
                    "option": "Projective",
                    "explanation": "A projective transform could do this, but it's more powerful (and complex) than needed. Similarity is the simplest class that fits.",
                    "correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "title": "Review and Reflect",
          "content": "Great job! We've taken our new tool, homogeneous coordinates, and used it to describe how objects move and resize in a 2D world.",
          "image": "Description: A summary diagram showing three icons. The first is an arrow labeled 'Translation'. The second is a rotating arrow labeled 'Rotation (Euclidean)'. The third is a rotating arrow that is also growing, labeled 'Scaling (Similarity)'. All three point to a single 3x3 matrix icon, symbolizing their unification.",
          "text": "In this lesson, you learned how to:\n- Use a **translation matrix** to shift an object.\n- Combine rotation and translation with a **Euclidean matrix** for rigid motion.\n- Add uniform scaling with a **Similarity matrix** to change an object's size.\n- Recognize that all these transformations preserve key properties, like angles or lengths.\n\nSo far, our objects have stayed perfectly rigid. But the world doesn't always look so neat. In the next lesson, we'll learn how to bend and distort reality to create perspective effects, just like a real camera does."
        }
      ]
    }
  }