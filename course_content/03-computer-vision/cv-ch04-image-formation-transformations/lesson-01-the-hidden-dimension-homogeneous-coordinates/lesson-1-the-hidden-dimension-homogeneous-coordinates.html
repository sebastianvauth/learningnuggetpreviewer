<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<link rel="stylesheet" href="../../styles/lesson.css">
<title>The Hidden Dimension ‚Äì Homogeneous Coordinates</title>
<script>
    window.MathJax = {
        tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
        options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <style>
        /* Specific Styles for this Interactive Module */
        #rayCanvas {
            background: #f8fafc;
            display: block;
            width: 100%;
            height: auto;
            min-height: auto; /* Override lesson.css */
            border-bottom: 2px solid #e2e8f0;
        }

        .controls-area {
            padding: 1.5rem;
            background: #ffffff;
            text-align: center;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .slider-group input[type="range"] {
            flex: 1;
            min-width: 200px;
            max-width: 350px;
            cursor: pointer;
            height: 6px;
            background: #e2e8f0;
            border-radius: 5px;
            appearance: none;
            outline: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #667eea;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .math-readout {
            background: #f1f5f9;
            padding: 0.75rem 1.25rem;
            border-radius: 8px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 1.1rem;
            font-weight: bold;
            color: #667eea;
            display: inline-block;
            margin: 1rem 0;
            border: 1px solid #e2e8f0;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.02);
        }

        .label-text {
            color: #64748b;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .label-text strong {
            color: #2d3748;
        }
    </style>
    </head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">

<section id="section1" class="visible">
    <h1>The Hidden Dimension ‚Äì Homogeneous Coordinates</h1>
    <h2>Beyond the Flat Plane</h2>
    <div class="image-placeholder">
        <img src="images/1.jpg" alt="3D coordinate system showing Ray Space. Origin O (camera center) connects via rays to points on a 2D plane at z=1." style="width: 100%; border-radius: 12px;">
    </div>
    <p>Welcome to the hidden dimension. If you remember graphing in high school, you likely used Cartesian coordinates: a simple \((x, y)\) grid. These are great for plotting a garden or a chessboard, but they have a fatal flaw when it comes to Computer Vision.</p>
    <div class="continue-button" onclick="showNextSection(2)">Continue</div>
</section>

<section id="section2">
    <h2>The Problem with Cartesian</h2>
    <p>In the real world, parallel train tracks appear to converge at the horizon. In standard Cartesian math, parallel lines never meet. This disconnect makes it mathematically messy to describe how a 3D world gets 'squashed' onto a 2D photograph.</p>
    <div class="continue-button" onclick="showNextSection(3)">Continue</div>
</section>

<section id="section3">
    <p>To solve this, we introduce a mathematical hack that powers almost every 3D game and camera system in existence: <strong>Homogeneous Coordinates</strong>.</p>
    <p>We are going to take our standard 2D point and add a 'hidden' third dimension, which we call \(w\).</p>
    <div class="continue-button" onclick="showNextSection(4)">Continue</div>
</section>

<section id="section4">
    <h2>The Math of the Hidden Dimension</h2>
    <p>Let's look at the math. A point in a 2D plane is typically represented as a vector \(\mathbf{x} = (x, y)^T\). In Homogeneous Coordinates, we represent this same point as a 3-element vector \(\tilde{\mathbf{x}}\) by adding that scale factor \(w\).</p>
    <p>The conversion looks like this:</p>
    <p>$$ \tilde{\mathbf{x}} = (wx, wy, w)^T $$</p>
    <div class="continue-button" onclick="showNextSection(5)">Continue</div>
</section>

<section id="section5">
    <p>Ideally, for simplicity, we often set \(w=1\). This gives us the <strong>Augmented Vector</strong>:</p>
    <p>$$ \mathbf{x}_{aug} = (x, y, 1)^T $$</p>
    <p>But here is the magic trick: In this system, vectors that differ only by a scale factor represent the <strong>exact same point</strong>.</p>
    <p>For example, the point \((2, 4, 1)\) is the exact same point as \((4, 8, 2)\) and \((100, 200, 100)\). They all live on the same 'ray' pointing from the origin.</p>
    <div class="continue-button" onclick="showNextSection(6)">Continue</div>
</section>

<section id="section6">
    <h3>Back Projection</h3>
    <p>To get back to our regular, comfortable Cartesian coordinates (Inhomogeneous), we perform <strong>Back Projection</strong>. We simply divide the first two numbers by the last number (\(w\)).</p>
    <p>Mathematically:</p>
    <p>$$ x = \frac{\tilde{x}}{\tilde{w}}, \quad y = \frac{\tilde{y}}{\tilde{w}} $$</p>
    <div class="test-your-knowledge">
        <h3>Check Your Understanding</h3>
        <h4>Convert the homogeneous vector \((10, 20, 5)^T\) back to Cartesian coordinates.</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Not quite. You need to divide the x and y components by the w component (5).')">
                \((10, 20)\)
            </div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! \(x = 10/5 = 2\) and \(y = 20/5 = 4\).')">
                \((2, 4)\)
            </div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'You multiplied instead of dividing! Remember, back projection divides by w.')">
                \((50, 100)\)
            </div>
        </div>
    </div>
    <div class="continue-button" id="continue-after-mini-quiz" onclick="showNextSection(7)" style="display: none;">Continue</div>
</section>

<section id="section7">
    <h2>Sliding Along the Ray</h2>
    <p>It might feel counter-intuitive that \((1, 2, 1)\) and \((10, 20, 10)\) are the same place. Let's visualize it.</p>
    <!-- START INTERACTIVE MODULE -->
    <div class="interactive-module-container">
        <canvas id="rayCanvas" width="600" height="300"></canvas>
        
        <div class="controls-area">
          <div class="slider-group">
              <span class="label-text" style="font-weight:bold;">w = 0.5</span>
              <input type="range" id="wSlider" min="0.5" max="3.0" step="0.1" value="1.0">
              <span class="label-text" style="font-weight:bold;">w = 3.0</span>
          </div>
      
          <div class="math-readout" id="vectorOutput">
              Homogeneous Vector: (2.0, 1.0, 1.0)
          </div>
          
          <p class="label-text">
              Base Point (Cartesian): <strong>(2, 1)</strong><br>
              <em>Drag slider to move the homogeneous point along the ray.</em>
          </p>
        </div>
      </div>
      <!-- END INTERACTIVE MODULE -->
  
  <script>
  (function() {
      const canvas = document.getElementById('rayCanvas');
      const ctx = canvas.getContext('2d');
      const slider = document.getElementById('wSlider');
      const output = document.getElementById('vectorOutput');
  
      // Configuration
      const basePoint = { x: 2, y: 1 }; // The Cartesian point (x, y)
      const padding = 40;
      
      // Canvas coordinate transforms
      // Origin will be bottom-left, shifted right slightly
      const origin = { x: 50, y: 250 }; 
      const scalePixels = 120; // 1 unit of w = 120 pixels
  
      function draw() {
          const w = parseFloat(slider.value);
          
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // 1. Draw Grid/Axes
          ctx.beginPath();
          ctx.strokeStyle = '#cbd5e1';
          ctx.lineWidth = 2;
          
          // Horizontal Axis (w)
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(canvas.width - 20, origin.y);
          
          // Vertical Axis (Space)
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(origin.x, 20);
          ctx.stroke();
  
          // Axis Labels
          ctx.fillStyle = '#64748b';
          ctx.font = '14px sans-serif';
          ctx.fillText("Origin (0,0,0)", origin.x, origin.y + 25);
          ctx.fillText("w (scale)", canvas.width - 70, origin.y + 25);
          ctx.fillText("Spatial Position", origin.x + 10, 30);
  
          // 2. Draw Image Plane (at w = 1)
          const planeX = origin.x + (1.0 * scalePixels);
          ctx.beginPath();
          ctx.setLineDash([5, 5]);
          ctx.strokeStyle = '#38a169'; // Greenish
          ctx.lineWidth = 2;
          ctx.moveTo(planeX, origin.y + 20);
          ctx.lineTo(planeX, 20);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Label Image Plane
          ctx.fillStyle = '#38a169';
          ctx.fillText("Image Plane (w=1)", planeX - 50, 15);
  
          // 3. Draw The Ray (Infinite)
          // Calculate slope based on basePoint.y (treating it as height)
          // We simulate a side view where vertical height = y
          // At w=3, height = basePoint.y * 3
          const maxW = 3.5; 
          const endX = origin.x + (maxW * scalePixels);
          const endY = origin.y - (basePoint.y * maxW * (scalePixels/2)); // Dividing scale for Y to fit screen better
          
          ctx.beginPath();
          ctx.strokeStyle = '#cbd5e1';
          ctx.lineWidth = 1;
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(endX, endY);
          ctx.stroke();
  
          // 4. Draw The Vector (Current w)
          const currentVecX = origin.x + (w * scalePixels);
          const currentVecY = origin.y - (basePoint.y * w * (scalePixels/2)); // Same Y scale ratio
  
          ctx.beginPath();
          ctx.strokeStyle = '#667eea'; // Primary Purple
          ctx.lineWidth = 4;
          ctx.lineCap = 'round';
          ctx.moveTo(origin.x, origin.y);
          ctx.lineTo(currentVecX, currentVecY);
          ctx.stroke();
  
          // Arrowhead
          const headLen = 15;
          const angle = Math.atan2(currentVecY - origin.y, currentVecX - origin.x);
          ctx.beginPath();
          ctx.moveTo(currentVecX, currentVecY);
          ctx.lineTo(currentVecX - headLen * Math.cos(angle - Math.PI / 6), currentVecY - headLen * Math.sin(angle - Math.PI / 6));
          ctx.lineTo(currentVecX - headLen * Math.cos(angle + Math.PI / 6), currentVecY - headLen * Math.sin(angle + Math.PI / 6));
          ctx.fillStyle = '#667eea';
          ctx.fill();
  
          // 5. Draw Fixed Point on Image Plane (w=1)
          const fixedPointX = planeX;
          const fixedPointY = origin.y - (basePoint.y * 1.0 * (scalePixels/2));
          
          ctx.beginPath();
          ctx.fillStyle = '#e53e3e'; // Red
          ctx.arc(fixedPointX, fixedPointY, 6, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#e53e3e';
          ctx.font = 'bold 12px sans-serif';
          ctx.fillText("P", fixedPointX + 10, fixedPointY + 5);
  
          // 6. Draw Current Tip Point
          if (Math.abs(w - 1.0) > 0.1) { // Only show ghost point if not overlapping P
              ctx.beginPath();
              ctx.fillStyle = '#667eea';
              ctx.arc(currentVecX, currentVecY, 4, 0, Math.PI * 2);
              ctx.fill();
          }
  
          // Update Math Text
          // We use toFixed(1) for display cleanliness
          const wx = (basePoint.x * w).toFixed(1);
          const wy = (basePoint.y * w).toFixed(1);
          const wStr = w.toFixed(1);
          output.innerText = `Homogeneous Vector: (${wx}, ${wy}, ${wStr})`;
      }
  
      // Event Listeners
      slider.addEventListener('input', draw);
      
      // Initial draw
      draw();
  })();
  </script>
  <!-- END INTERACTIVE MODULE -->
    <p>Notice that as you move the slider, the vector \((wx, wy, w)\) grows and shrinks, but it always points along the exact same line. Since the image plane is a slice of this space, the 'pixel' never moves.</p>
    <div class="continue-button" onclick="showNextSection(8)">Continue</div>
</section>

<section id="section8">
    <h2>To Infinity... and Beyond</h2>
    <p>Now, let's push this system to its limit. In Cartesian coordinates, you can't write down the coordinates of a point at infinity. It's just... undefined.</p>
    <div class="check-your-knowledge">
        <h3>Stop and Think</h3>
        <h4>What happens if \(w = 0\)? If we divide by \(w\) to get back to real coordinates \((x/w)\), we get division by zero. What concept in geometry does a point with no specific position but a specific direction represent?</h4>
        <div id="cuy-infinity-answer" style="display:none;" class="animate-in">
            <strong>Answer:</strong> It represents a Direction, or a Point at Infinity. Think about train tracks converging in the distance. They meet at a 'Vanishing Point' that effectively sits at infinity.
        </div>
        <button class="reveal-button" onclick="revealAnswer('cuy-infinity-answer')">Reveal Answer</button>
    </div>
    <div class="continue-button" onclick="showNextSection(9)">Continue</div>
</section>

<section id="section9">
    <p>Homogeneous coordinates allow us to handle infinity gracefully. A point like \((x, y, 0)\) isn't a location; it's a direction. This is crucial for calculating vanishing points in perspective drawings.</p>
    <div class="image-placeholder">
        <img src="images/2.jpg" alt="Meme: Galaxy Brain comparing Cartesian (x, y), Augmented (x, y, 1), and Homogeneous (wx, wy, w) coordinates." style="width: 100%; border-radius: 12px;">
    </div>
    <div class="continue-button" onclick="showNextSection(10)">Continue</div>
</section>

<section id="section10">
    <h2>Why It Matters</h2>
    <p>You might be asking: "Why make things complicated with an extra number?"</p>
    <p>Without this notation, math in Computer Vision breaks down. Specifically, <strong>Linearity</strong>.</p>
    <p>In the next lesson, we will see that operations like translation (moving an image left or right) cannot be written as a \(2\times2\) matrix multiplication. But if we bump it up to \(3\times3\) using homogeneous coordinates, everything becomes a clean, linear matrix multiplication.</p>
    <div class="why-it-matters">
        <h3>Why It Matters</h3>
        <p>This notation unifies all our math. Translation, Rotation, Scaling, and Perspective Projection can all be treated as the exact same type of operation: multiplying a vector by a matrix. This makes computer graphics and vision computations incredibly fast.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(11)">Continue</div>
</section>

<section id="section11">
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Homogeneous Coordinates</h4>
        <p>A system where a 2D point \((x, y)\) is represented by a 3D vector \((wx, wy, w)\). Vectors differing only by a scale factor represent the same point.</p>
        
        <h4>Ideal Point</h4>
        <p>Also known as a Point at Infinity. A homogeneous point where the scale factor \(w = 0\). It represents a direction rather than a specific location.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(12)">Continue</div>
</section>

<section id="section12">
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>Which of the following vectors represents the same 2D point as \((1, 2, 1)^T\)?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'No, having w=0 makes this an Ideal Point (a direction), not a standard point.')">
                \((2, 4, 0)^T\)
            </div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! If you divide by w=10, you get \((1, 2)\), which matches the original point.')">
                \((10, 20, 10)^T\)
            </div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Not quite. If you back-project this, you get \((0.5, 1)\), which is different from \((1, 2)\).')">
                \((1, 2, 2)^T\)
            </div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Incorrect. This represents the Cartesian point \((2, 4)\), not \((1, 2)\).')">
                \((2, 4, 1)^T\)
            </div>
        </div>
    </div>
    
    <div class="faq-section animate-in" style="margin-top: 2rem;">
        <h3>Frequently Asked</h3>
        <h4>Why do we usually set w=1?</h4>
        <p>It is purely for convenience! When \(w=1\), the first two coordinates \((x, y, 1)\) look exactly like the Cartesian coordinates you are used to. We keep \(w=1\) until we perform a transformation (like a projection) that forces \(w\) to change.</p>
    </div>

    <div class="continue-button" id="continue-after-test-knowledge" onclick="showNextSection(13)" style="display: none;">Continue</div>
</section>

<section id="section13">
    <h2>Review and Reflect</h2>
    <p>You have taken the first step into the geometry of computer vision.</p>
    <p>In this lesson, you learned that by adding a 'hidden dimension' \(w\), we can represent 2D points as rays in 3D space.</p>
    <ul>
        <li>You learned how to convert to Homogeneous Coordinates: \(\tilde{\mathbf{x}} = (wx, wy, w)^T\).</li>
        <li>You learned how to Back Project: \(x = \tilde{x}/\tilde{w}\).</li>
        <li>You discovered that points with \(w=0\) represent infinity.</li>
    </ul>
    <p>In the next lesson, we will put this new coordinate system to work. We will use it to move, rotate, and resize images using simple matrix math.</p>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">‚úì Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 13;

updateProgress();
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event && event.target;
    if (!nextSectionElement) return;
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    setTimeout(() => { nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
    
    // Only show continue button if answer is correct
    if (!isCorrect) return;
    
    // Logic for Section 6 (Mini Quiz)
    const parentSection = element.closest('section');
    if (parentSection && parentSection.id === 'section6') {
        const continueButton = document.getElementById('continue-after-mini-quiz');
        if (continueButton && continueButton.style.display === 'none') {
             setTimeout(() => {
                continueButton.style.display = 'block';
                continueButton.classList.add('show-with-animation');
            }, 800);
        }
    }

    // Logic for Section 12 (Final Test)
    if (parentSection && parentSection.id === 'section12') {
        const continueButton = document.getElementById('continue-after-test-knowledge');
        if (continueButton && continueButton.style.display === 'none') {
            setTimeout(() => {
                continueButton.style.display = 'block';
                continueButton.classList.add('show-with-animation');
            }, 800);
        }
    }
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // Default placeholders - these should be updated by the LMS or URL params
                let courseId = 'computer-vision';
                let pathId = 'geometry-foundations';
                let moduleId = 'cv-ch2-m1-coordinates';
                let lessonId = 'cv-ch2-l2-homogeneous';
                
                if (window.parent.currentRoute) {
                    const route = window.parent.currentRoute;
                    if (route.courseId) courseId = route.courseId;
                    if (route.pathId) pathId = route.pathId;
                    if (route.moduleId) moduleId = route.moduleId;
                    if (route.lessonId) lessonId = route.lessonId;
                }
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('course')) courseId = urlParams.get('course');
                if (urlParams.get('path')) pathId = urlParams.get('path');
                if (urlParams.get('module')) moduleId = urlParams.get('module');
                if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = '‚úÖ Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv-ch2-l2_homogeneous_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['üéâ', 'üéä', '‚ú®', 'üåü', 'üìê', 'üß†', 'üöÄ'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = '‚óè';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = 'üéâ Lesson Completed! Dimension Unlocked! üéâ';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    
    const isCompleted = localStorage.getItem('lesson_cv-ch2-l2_homogeneous_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = '‚úÖ Completed!';
    }
});
</script>
</body>
</html>