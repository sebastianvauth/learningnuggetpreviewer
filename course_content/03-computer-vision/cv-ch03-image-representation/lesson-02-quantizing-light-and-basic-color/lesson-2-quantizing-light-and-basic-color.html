<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<link rel="stylesheet" href="../../styles/lesson.css">
<title>Quantizing Light & Basic Color</title>
<script>
window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">

<!-- SECTION 1: Filling the Grid -->
<section id="section1" class="visible">
    <div class="image-placeholder">
        <img src="images/1.jpg" alt="Digital sensor grid filling with gray shades">
    </div>
    <h1>Filling the Grid</h1>
    <h2>Turning Light into Numbers</h2>
    <p>Welcome back! In the last lesson, we built the 'grid'â€”the spatial structure of a digital image. But right now, that grid is just a collection of empty boxes. To create an actual image, we need to fill those boxes with information.</p>
    <div class="continue-button" onclick="showNextSection(2)">Continue</div>
</section>

<!-- SECTION 2: Quantizing Intensity -->
<section id="section2">
    <h2>Quantizing Intensity</h2>
    <p>Imagine you are holding a light meter in a dark room. You point it at a shadow, and it registers a tiny voltage. You point it at a lightbulb, and the voltage spikes. The sensor in a camera works exactly the same wayâ€”it converts photons into an analog electrical signal.</p>
    <div class="continue-button" onclick="showNextSection(3)">Continue</div>
</section>

<!-- SECTION 3: ADC / Quantization -->
<section id="section3">
    <p>But computers don't speak 'voltage'; they speak integers. We need to convert that smooth, continuous wave of electricity into a specific, discrete number. This process is called <strong>Analog to Digital Conversion (ADC)</strong>, or more specifically, <strong>Quantization</strong>.</p>
    <!-- START INTERACTIVE MODULE -->
<div class="interactive-module-container" style="background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; padding: 20px; text-align: center; font-family: -apple-system, sans-serif;">
    
    <!-- Canvas -->
    <canvas id="adcCanvas" width="800" height="300" style="width: 100%; max-width: 100%; height: auto; background: white; border-radius: 8px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);"></canvas>
    
    <!-- Controls -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; text-align: left;">
        
        <!-- Sampling Rate Control -->
        <div class="control-group">
            <label style="display: block; font-weight: 600; color: #4a5568; margin-bottom: 8px;">
                Sampling Rate (X-Axis)
                <span id="rateDisplay" style="float: right; color: #667eea;">10 Samples</span>
            </label>
            <input type="range" id="sampleRate" min="4" max="64" value="10" step="1" 
                   style="width: 100%; accent-color: #667eea; cursor: pointer;">
            <p style="font-size: 0.85rem; color: #718096; margin-top: 5px;">Determines how often we measure the signal.</p>
        </div>

        <!-- Bit Depth Control -->
        <div class="control-group">
            <label style="display: block; font-weight: 600; color: #4a5568; margin-bottom: 8px;">
                Bit Depth (Y-Axis)
                <span id="depthDisplay" style="float: right; color: #764ba2;">3-bit (8 Levels)</span>
            </label>
            <input type="range" id="bitDepth" min="1" max="5" value="3" step="1" 
                   style="width: 100%; accent-color: #764ba2; cursor: pointer;">
            <p style="font-size: 0.85rem; color: #718096; margin-top: 5px;">Determines how many intensity values exist.</p>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('adcCanvas');
        const ctx = canvas.getContext('2d');
        const rateSlider = document.getElementById('sampleRate');
        const depthSlider = document.getElementById('bitDepth');
        const rateDisplay = document.getElementById('rateDisplay');
        const depthDisplay = document.getElementById('depthDisplay');

        // Configuration
        const margin = 20;
        let width = canvas.width;
        let height = canvas.height;
        let amplitude = (height / 2) - 40; // Leave room for margins
        let centerY = height / 2;

        function resize() {
            // Optional: Handle responsiveness if canvas size changes
            // For now, relies on CSS width: 100%
        }

        function getQuantizedY(rawY, levels) {
            // 1. Normalize rawY (-1 to 1) to (0 to 1)
            let normalized = (rawY + 1) / 2;
            
            // 2. Scale to number of levels (e.g., 0 to 7)
            let maxLevel = levels - 1;
            let level = Math.round(normalized * maxLevel);
            
            // 3. Map back to -1 to 1 range
            let quantizedNorm = level / maxLevel;
            return (quantizedNorm * 2) - 1;
        }

        function draw() {
            const numSamples = parseInt(rateSlider.value);
            const bitDepth = parseInt(depthSlider.value);
            const numLevels = Math.pow(2, bitDepth);

            // Update Labels
            rateDisplay.innerText = `${numSamples} Samples`;
            depthDisplay.innerText = `${bitDepth}-bit (${numLevels} Levels)`;

            // Clear Canvas
            ctx.clearRect(0, 0, width, height);

            // 1. Draw Quantization Grid (Horizontal Lines)
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            // Calculate step size for grid
            // We want lines from normalized 0 to 1
            for (let i = 0; i < numLevels; i++) {
                let normY = i / (numLevels - 1); // 0 to 1
                let y = centerY - ((normY * 2 - 1) * amplitude); // Flip Y for canvas
                
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // 2. Draw Analog Signal (Smooth Sine Wave)
            ctx.beginPath();
            ctx.strokeStyle = '#cbd5e1'; // Light gray
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]); // Dashed line to represent "Ghost" analog signal

            for (let x = 0; x <= width; x++) {
                // Map x to angle (2 full cycles)
                let angle = (x / width) * Math.PI * 4;
                let rawY = Math.sin(angle);
                let y = centerY - (rawY * amplitude);
                
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            // 3. Draw Digital Signal (Bars)
            const barWidth = (width / numSamples) * 0.8; // 80% of space
            
            for (let i = 0; i < numSamples; i++) {
                // Calculate X position
                let xCenter = (i * (width / numSamples)) + (width / numSamples / 2);
                
                // Calculate true analog value at this point
                let angle = (xCenter / width) * Math.PI * 4;
                let rawY = Math.sin(angle);
                
                // Quantize!
                let quantY = getQuantizedY(rawY, numLevels);
                
                // Convert to screen coordinates
                let screenY = centerY - (quantY * amplitude);
                
                // Draw bar logic
                // Gradient for bars
                let grad = ctx.createLinearGradient(0, height, 0, 0);
                grad.addColorStop(0, '#667eea');
                grad.addColorStop(1, '#764ba2');
                
                ctx.fillStyle = grad;
                ctx.strokeStyle = '#553c9a';
                ctx.lineWidth = 1;

                // Draw the bar from center line (zero crossing) to value
                // Note: centerY is 0 crossing.
                ctx.beginPath();
                ctx.rect(xCenter - barWidth/2, centerY, barWidth, screenY - centerY);
                ctx.fill();
                // ctx.stroke();

                // Draw a dot at the top/bottom
                ctx.beginPath();
                ctx.arc(xCenter, screenY, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#2d3748';
                ctx.fill();
            }

            // Draw center axis
            ctx.beginPath();
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 1;
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
        }

        // Event Listeners
        rateSlider.addEventListener('input', draw);
        depthSlider.addEventListener('input', draw);

        // Initial Draw
        draw();
    })();
    </script>
</div>
<!-- END INTERACTIVE MODULE -->
    <div class="continue-button" onclick="showNextSection(4)">Continue</div>
</section>

<!-- SECTION 4: Bit Depth -->
<section id="section4">
    <p>How many numbers do we have to choose from? That depends on the <strong>Bit Depth</strong>. The bit depth tells us how many bits of memory are allocated to store the brightness value of a single pixel.</p>
    <div class="continue-button" onclick="showNextSection(5)">Continue</div>
</section>

<!-- SECTION 5: Math Formula -->
<section id="section5">
    <p>The formula to calculate the number of available intensity levels (\(N\)) based on bit depth (\(b\)) is:</p>
    <p>$$ N = 2^b $$</p>
    <div class="continue-button" onclick="showNextSection(6)">Continue</div>
</section>

<!-- SECTION 6: 8-bit Math -->
<section id="section6">
    <p>Let's look at the most common format: the <strong>8-bit image</strong>. If we have 8 bits, we calculate the levels like this:</p>
    <p>$$ N = 2^8 = 256 $$</p>
    <div class="continue-button" onclick="showNextSection(7)">Continue</div>
</section>

<!-- SECTION 7: Range & TYK -->
<section id="section7">
    <p>This gives us 256 possible intensity levels. In computer vision, we typically start counting at 0, so the range is <strong>0 (Pure Black) to 255 (Pure White)</strong>.</p>
    
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>If you were working with a strictly 1-bit image (often called a binary image), how many intensity levels would you have?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Not quite. \\(2^1\\) is not 1.')">1 level</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'That would be an 8-bit image. 1-bit is much smaller.')">256 levels</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! \\(2^1 = 2\\). The pixel can only be 0 (Black) or 1 (White). This is often used for masks or simple text scans.')">2 levels</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Binary implies powers of 2. 10 isn\'t a power of 2.')">10 levels</div>
        </div>
    </div>
    
    <div class="continue-button" id="continue-after-tyk1" onclick="showNextSection(8)" style="display: none;">Continue</div>
</section>

<!-- SECTION 8: Vocab Quantization -->
<section id="section8">
    <p>We use 8-bit because 256 levels is roughly the limit of what the human eye can distinguish in a smooth gradient. If we drop below that, things get ugly.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Quantization</h4>
        <p>The process of mapping a continuous range of values (like infinite light intensities) to a finite set of discrete values (like integers 0-255).</p>
    </div>
    <div class="continue-button" onclick="showNextSection(9)">Continue</div>
</section>

<!-- SECTION 9: Banding Experiment -->
<section id="section9">
    <p>Try this experiment. We've taken a standard 8-bit portrait. Use the slider to reduce the bit depth and see what happens to the smoothness of the image.</p>
    <!-- START INTERACTIVE MODULE: BIT DEPTH & HISTOGRAM -->
<div class="interactive-module-container" style="background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; padding: 20px; font-family: -apple-system, sans-serif;">
    
    <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; align-items: flex-start;">
        
        <!-- Left: Image View -->
        <div style="flex: 1; min-width: 280px; text-align: center;">
            <div style="font-weight: 600; color: #4a5568; margin-bottom: 10px;">Simulated Portrait</div>
            <canvas id="portraitCanvas" width="300" height="300" style="width: 100%; max-width: 300px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); background: #000;"></canvas>
        </div>

        <!-- Right: Histogram View -->
        <div style="flex: 1; min-width: 280px; text-align: center;">
            <div style="font-weight: 600; color: #4a5568; margin-bottom: 10px;">Live Histogram</div>
            <canvas id="histCanvas" width="300" height="300" style="width: 100%; max-width: 300px; border-radius: 8px; border: 1px solid #cbd5e1; background: #fff;"></canvas>
        </div>
    </div>

    <!-- Controls -->
    <div style="margin-top: 25px; padding: 15px; background: white; border-radius: 8px; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <label for="bitDepthSlider" style="font-weight: 700; color: #2d3748;">Bit Depth</label>
            <span id="bitDepthValue" style="background: #667eea; color: white; padding: 4px 12px; border-radius: 20px; font-size: 0.9rem; font-weight: 600;">8-bit</span>
        </div>
        
        <input type="range" id="bitDepthSlider" min="1" max="8" value="8" step="1" 
               style="width: 100%; height: 8px; background: #e2e8f0; border-radius: 5px; outline: none; -webkit-appearance: none; appearance: none; cursor: pointer;">
        
        <div style="display: flex; justify-content: space-between; margin-top: 5px; color: #718096; font-size: 0.8rem;">
            <span>1-bit (B&W)</span>
            <span>4-bit (16 Colors)</span>
            <span>8-bit (256 Colors)</span>
        </div>
        
        <p id="bandingText" style="margin-top: 15px; font-size: 0.95rem; color: #4a5568; text-align: left;">
            <strong>Result:</strong> <span style="color: #667eea;">256 intensity levels.</span> Smooth gradients are visible.
        </p>
    </div>

    <script>
    (function() {
        // --- Setup ---
        const pCanvas = document.getElementById('portraitCanvas');
        const pCtx = pCanvas.getContext('2d');
        const hCanvas = document.getElementById('histCanvas');
        const hCtx = hCanvas.getContext('2d');
        const slider = document.getElementById('bitDepthSlider');
        const label = document.getElementById('bitDepthValue');
        const text = document.getElementById('bandingText');

        const width = pCanvas.width;
        const height = pCanvas.height;

        // --- 1. Create Source Image (Offscreen) ---
        // We create a "perfect" gradient image in memory to serve as the source.
        // This prevents the quantization from compounding (degrading the image permanently)
        const sourceCanvas = document.createElement('canvas');
        sourceCanvas.width = width;
        sourceCanvas.height = height;
        const sCtx = sourceCanvas.getContext('2d');

        // Draw a synthetic "Portrait" (Smooth spheres to represent a face)
        // Background
        const bgGrad = sCtx.createLinearGradient(0, 0, width, height);
        bgGrad.addColorStop(0, '#1a202c');
        bgGrad.addColorStop(1, '#2d3748');
        sCtx.fillStyle = bgGrad;
        sCtx.fillRect(0, 0, width, height);

        // "Face" (Main Sphere)
        const faceGrad = sCtx.createRadialGradient(width/2 - 20, height/2 - 20, 10, width/2, height/2, 110);
        faceGrad.addColorStop(0, '#ffdbac'); // Highlight
        faceGrad.addColorStop(0.4, '#e0ac69'); // Midtone
        faceGrad.addColorStop(1, 'rgba(80, 50, 30, 0)'); // Shadow fade
        sCtx.fillStyle = faceGrad;
        sCtx.beginPath();
        sCtx.arc(width/2, height/2, 110, 0, Math.PI * 2);
        sCtx.fill();

        // "Chin/Neck" shadow area
        const neckGrad = sCtx.createRadialGradient(width/2 + 40, height/2 + 80, 5, width/2 + 20, height/2 + 80, 60);
        neckGrad.addColorStop(0, '#e0ac69');
        neckGrad.addColorStop(1, 'rgba(60, 40, 20, 0)');
        sCtx.fillStyle = neckGrad;
        sCtx.beginPath();
        sCtx.arc(width/2 + 20, height/2 + 80, 60, 0, Math.PI * 2);
        sCtx.fill();

        // Get the "Perfect" source data
        const sourceImageData = sCtx.getImageData(0, 0, width, height);

        // --- Functions ---

        function process() {
            const bits = parseInt(slider.value);
            const levels = Math.pow(2, bits);
            
            // Update UI
            label.innerText = `${bits}-bit`;
            updateExplanation(bits, levels);

            // Create new ImageData for the visible canvas
            const outputImage = pCtx.createImageData(width, height);
            const sData = sourceImageData.data;
            const oData = outputImage.data;

            // Histogram array (0-255)
            const histogram = new Array(256).fill(0);
            let maxCount = 0;

            // Loop through pixels
            for (let i = 0; i < sData.length; i += 4) {
                // We only need to quantize RGB. Alpha (sData[i+3]) is 255.
                
                // Simple Grayscale Quantization Logic applied to RGB channels
                // Formula: floor(value / step) * step
                // Step size based on 256 total values divided by available levels
                
                // Note: Standard Quantization often normalizes 0-1, but for 8-bit int:
                // Level = floor(val * (levels / 256))
                // Output = floor(Level * (255 / (levels - 1)))
                
                let r = sData[i];
                let g = sData[i+1];
                let b = sData[i+2];

                // Quantize Red
                let levelR = Math.floor(r * (levels / 256));
                let outR = Math.floor(levelR * (255 / (levels - 1)));
                if (bits === 1) outR = levelR * 255; // Handle 1-bit edge case cleanly
                
                // Quantize Green
                let levelG = Math.floor(g * (levels / 256));
                let outG = Math.floor(levelG * (255 / (levels - 1)));
                if (bits === 1) outG = levelG * 255;

                // Quantize Blue
                let levelB = Math.floor(b * (levels / 256));
                let outB = Math.floor(levelB * (255 / (levels - 1)));
                if (bits === 1) outB = levelB * 255;

                // Set Output
                oData[i] = outR;
                oData[i+1] = outG;
                oData[i+2] = outB;
                oData[i+3] = 255; // Alpha

                // Histogram Stats (Using converting to grayscale for histogram simplicity)
                // Luminosity formula: 0.299R + 0.587G + 0.114B
                let gray = Math.round(0.299*outR + 0.587*outG + 0.114*outB);
                histogram[gray]++;
                if (histogram[gray] > maxCount) maxCount = histogram[gray];
            }

            // Draw processed image
            pCtx.putImageData(outputImage, 0, 0);

            // Draw Histogram
            drawHistogram(histogram, maxCount, levels);
        }

        function drawHistogram(hist, max, levels) {
            hCtx.clearRect(0, 0, hCanvas.width, hCanvas.height);
            
            // Draw Axis
            hCtx.strokeStyle = '#cbd5e1';
            hCtx.lineWidth = 1;
            hCtx.beginPath();
            hCtx.moveTo(20, hCanvas.height - 20);
            hCtx.lineTo(hCanvas.width - 20, hCanvas.height - 20); // X axis
            hCtx.stroke();

            const barWidth = (hCanvas.width - 40) / 256;
            
            // Draw Bars
            // Gradient for bars
            const grad = hCtx.createLinearGradient(0, hCanvas.height, 0, 0);
            grad.addColorStop(0, '#4facfe');
            grad.addColorStop(1, '#00f2fe');
            hCtx.fillStyle = grad;

            for (let i = 0; i < 256; i++) {
                if (hist[i] > 0) {
                    // Logarithmic scaling for histogram usually looks better, 
                    // but linear shows the "spikes" of quantization better.
                    const barHeight = (hist[i] / max) * (hCanvas.height - 40);
                    const x = 20 + (i * barWidth);
                    const y = hCanvas.height - 20 - barHeight;
                    
                    // To make spikes visible even if 1px wide
                    // If levels are low (sparse), make bars wider visually?
                    // No, let's keep it accurate to show the GAPS.
                    hCtx.fillRect(x, y, Math.max(barWidth, 1), barHeight);
                }
            }
        }

        function updateExplanation(bits, levels) {
            let desc = "";
            let color = "#667eea"; // Default purple
            
            if (bits >= 7) {
                desc = `Smooth gradients. The histogram is full and continuous (mountain shape).`;
            } else if (bits >= 5) {
                desc = `Slight noise visible, but acceptable. Histogram shows small gaps.`;
            } else if (bits >= 3) {
                desc = `Visible <strong>Banding</strong>. The smooth skin tone is breaking into distinct rings.`;
                color = "#d69e2e"; // Orange warning
            } else {
                desc = `Severe Posterization! The histogram has collapsed into just ${levels} distinct spikes.`;
                color = "#e53e3e"; // Red alert
            }
            
            text.innerHTML = `<strong>Result:</strong> <span style="color:${color}; font-weight:bold">${levels} intensity levels.</span> ${desc}`;
        }

        // --- Event Listeners ---
        slider.addEventListener('input', process);

        // --- Init ---
        process();

    })();
    </script>
</div>
<!-- END INTERACTIVE MODULE -->
    <p>Notice how at lower bit depths, smooth transitions (like the skin on the face or the background gradient) turn into blocky stripes? That artifact is called <strong>posterization</strong> or <strong>banding</strong>.</p>
    <div class="continue-button" onclick="showNextSection(10)">Continue</div>
</section>

<!-- SECTION 10: Why it Matters -->
<section id="section10">
    <p>In computer vision, these 'bands' can be dangerous. An algorithm might mistake a band for an edge of an object!</p>
    <div class="why-it-matters">
        <h3>Why It Matters</h3>
        <p>Choosing the wrong bit depth can ruin image processing tasks. If you use low bit-depth images, your edge detection algorithms might detect the 'bands' in a blue sky as physical objects, confusing your AI.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(11)">Continue</div>
</section>

<!-- SECTION 11: Adding Color Intro -->
<section id="section11">
    <h2>Adding Color</h2>
    <p>So far, we've only talked about intensityâ€”light vs. dark. That gives us a grayscale image. But the world is colorful. To represent color, we use <strong>Color Models</strong>.</p>
    <div class="continue-button" onclick="showNextSection(12)">Continue</div>
</section>

<!-- SECTION 12: RGB -->
<section id="section12">
    <p>The most common model in digital screens is <strong>RGB (Red, Green, Blue)</strong>. This is an <strong>Additive Color Model</strong>.</p>
    <div class="continue-button" onclick="showNextSection(13)">Continue</div>
</section>

<!-- SECTION 13: Interactive Spotlights -->
<section id="section13">
    <p>Additive means we start with Black (no light) and <em>add</em> colored light to create other colors.</p>
    <!-- START INTERACTIVE MODULE: RGB ADDITIVE MIXING -->
<div class="interactive-module-container" style="background: #1a202c; border: 2px solid #2d3748; border-radius: 12px; overflow: hidden; font-family: -apple-system, sans-serif;">
    
    <!-- Canvas Container -->
    <div style="position: relative; height: 350px; background: #000; cursor: crosshair;">
        <canvas id="rgbCanvas" style="display: block; width: 100%; height: 100%;"></canvas>
        
        <!-- Instruction overlay that fades out -->
        <div id="rgbOverlay" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: rgba(255,255,255,0.7); pointer-events: none; text-align: center; transition: opacity 0.5s;">
            <div style="font-size: 2rem;">ðŸ‘†</div>
            <div style="font-weight: 600;">Drag the lights</div>
        </div>
    </div>

    <!-- Controls -->
    <div style="padding: 20px; background: #f7fafc; border-top: 1px solid #e2e8f0;">
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
            
            <!-- Red Control -->
            <div style="flex: 1; min-width: 120px; text-align: center;">
                <label style="color: #e53e3e; font-weight: 700; display: block; margin-bottom: 5px;">RED Intensity</label>
                <input type="range" id="sliderR" min="0" max="255" value="255" 
                       style="width: 100%; accent-color: #e53e3e; cursor: pointer;">
            </div>

            <!-- Green Control -->
            <div style="flex: 1; min-width: 120px; text-align: center;">
                <label style="color: #38a169; font-weight: 700; display: block; margin-bottom: 5px;">GREEN Intensity</label>
                <input type="range" id="sliderG" min="0" max="255" value="255" 
                       style="width: 100%; accent-color: #38a169; cursor: pointer;">
            </div>

            <!-- Blue Control -->
            <div style="flex: 1; min-width: 120px; text-align: center;">
                <label style="color: #3182ce; font-weight: 700; display: block; margin-bottom: 5px;">BLUE Intensity</label>
                <input type="range" id="sliderB" min="0" max="255" value="255" 
                       style="width: 100%; accent-color: #3182ce; cursor: pointer;">
            </div>
        </div>
    </div>

    <script>
    (function() {
        const canvas = document.getElementById('rgbCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('rgbOverlay');
        
        // Canvas Sizing
        // We look at the container's rendered size to set the canvas buffer size
        function resize() {
            if (!canvas.parentElement) return;
            const width = canvas.parentElement.clientWidth;
            const height = canvas.parentElement.clientHeight;
            
            // Only resize if we have a visible size
            if (width > 0 && height > 0) {
                canvas.width = width;
                canvas.height = height;
            }
        }
        window.addEventListener('resize', resize);

        // State
        const lights = [
            { color: 'r', r: 255, g: 0, b: 0, x: 0.35, y: 0.4, dragging: false }, // Red
            { color: 'g', r: 0, g: 255, b: 0, x: 0.65, y: 0.4, dragging: false }, // Green
            { color: 'b', r: 0, g: 0, b: 255, x: 0.5, y: 0.7, dragging: false }   // Blue
        ];
        
        const radius = 100; // Spotlight radius
        let isInteracting = false;

        // Sliders
        const sliderR = document.getElementById('sliderR');
        const sliderG = document.getElementById('sliderG');
        const sliderB = document.getElementById('sliderB');

        // Main Draw Loop
        function draw() {
            // Guard against zero-sized canvas (happens if section is hidden on load)
            if (canvas.width === 0 || canvas.height === 0) {
                resize();
                if (canvas.width === 0) {
                    requestAnimationFrame(draw);
                    return;
                }
            }

            // 1. Clear background (Black surface)
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. Set Blend Mode to ADDITIVE
            // 'lighter' adds the RGB values of layers. 
            // Red (255,0,0) + Green (0,255,0) = Yellow (255,255,0)
            ctx.globalCompositeOperation = 'lighter';

            lights.forEach(light => {
                // Determine current intensity from sliders
                let intensity = 1;
                if(light.color === 'r') intensity = sliderR.value / 255;
                if(light.color === 'g') intensity = sliderG.value / 255;
                if(light.color === 'b') intensity = sliderB.value / 255;

                // Calculate pixel positions
                const lx = light.x * canvas.width;
                const ly = light.y * canvas.height;

                // Create Gradient for Spotlight falloff
                // Inner color is the light color, outer is transparent
                const grad = ctx.createRadialGradient(lx, ly, 0, lx, ly, radius * 1.5);
                
                // Color string: "rgba(255, 0, 0, intensity)"
                const cVal = `rgba(${light.r}, ${light.g}, ${light.b}`;
                
                grad.addColorStop(0, `${cVal}, ${intensity})`);     // Center: Full color
                grad.addColorStop(0.5, `${cVal}, ${intensity * 0.5})`); 
                grad.addColorStop(1, `${cVal}, 0)`);               // Edge: Transparent

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(lx, ly, radius * 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // 3. Draw Handles (User Interface)
            // Switch back to normal blending so handles appear ON TOP of lights
            ctx.globalCompositeOperation = 'source-over';

            lights.forEach(light => {
                const lx = light.x * canvas.width;
                const ly = light.y * canvas.height;

                // Draw simple ring handle
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(lx, ly, 10, 0, Math.PI * 2);
                ctx.stroke();
                
                // Add a "Glow" to the handle based on its color
                ctx.fillStyle = `rgba(${light.r}, ${light.g}, ${light.b}, 1)`;
                ctx.beginPath();
                ctx.arc(lx, ly, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            requestAnimationFrame(draw);
        }

        // --- Interaction Logic ---

        function getMousePos(evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleStart(evt) {
            // Hide instructions on first interaction
            if (!isInteracting) {
                overlay.style.opacity = '0';
                isInteracting = true;
            }
            
            const pos = getMousePos(evt);
            
            // Check if clicking near a light center
            // Reverse loop so we grab the one visually on top first (though with additive they blend)
            for (let i = lights.length - 1; i >= 0; i--) {
                const l = lights[i];
                const lx = l.x * canvas.width;
                const ly = l.y * canvas.height;
                
                // Hit detection radius (handle size + buffer)
                const dist = Math.hypot(pos.x - lx, pos.y - ly);
                
                if (dist < 30) {
                    l.dragging = true;
                    // Prevent default touch scrolling
                    if(evt.cancelable && evt.type === 'touchstart') evt.preventDefault(); 
                    break; 
                }
            }
        }

        function handleMove(evt) {
            const pos = getMousePos(evt);
            let needsUpdate = false;

            lights.forEach(l => {
                if (l.dragging) {
                    // Update normalized coordinates (0.0 to 1.0)
                    l.x = pos.x / canvas.width;
                    l.y = pos.y / canvas.height;
                    
                    // Clamp to screen
                    l.x = Math.max(0, Math.min(1, l.x));
                    l.y = Math.max(0, Math.min(1, l.y));
                    
                    needsUpdate = true;
                    if(evt.cancelable) evt.preventDefault();
                }
            });
        }

        function handleEnd() {
            lights.forEach(l => l.dragging = false);
        }

        // Mouse Events
        canvas.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        // Touch Events
        canvas.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);

        // Use MutationObserver to detect when section becomes visible
        const section13 = document.getElementById('section13');
        if (section13 && typeof MutationObserver !== 'undefined') {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.attributeName === 'class' && section13.classList.contains('visible')) {
                        resize();
                        // Once we've resized once while visible, we can stop observing
                        // but keep window resize listener active
                    }
                });
            });
            observer.observe(section13, { attributes: true });
        }

        // Start
        setTimeout(() => {
             resize();
             draw();
        }, 100);

    })();
    </script>
</div>
<!-- END INTERACTIVE MODULE -->
    <div class="continue-button" onclick="showNextSection(14)">Continue</div>
</section>

<!-- SECTION 14: Monitor Explanation -->
<section id="section14">
    <p>This is exactly how your monitor or phone screen works. It has millions of tiny red, green, and blue lights. When they all turn on together, you see white.</p>
    <div class="continue-button" onclick="showNextSection(15)">Continue</div>
</section>

<!-- SECTION 15: CMYK -->
<section id="section15">
    <p>However, if you've ever changed a printer cartridge, you know they don't use Red, Green, and Blue. They use <strong>Cyan, Magenta, Yellow, and Key (Black)</strong> (CMYK).</p>
    <div class="image-placeholder">
        <img src="images/2.jpg" alt="Diagram comparing Additive (RGB) vs Subtractive (CMYK) color models">
    </div>
    <div class="continue-button" onclick="showNextSection(16)">Continue</div>
</section>

<!-- SECTION 16: Subtractive & StopThink -->
<section id="section16">
    <p>This is a <strong>Subtractive Color Model</strong>. Paint and ink don't emit light; they reflect it. A yellow ink works by <em>subtracting</em> (absorbing) blue light and reflecting the rest.</p>
    
    <div class="stop-and-think">
        <h3>Stop &amp; Think</h3>
        <h4>Why can't we just use RGB ink for printers? Why do we have to switch to CMY?</h4>
        <div id="stopthink-answer" style="display:none;" class="animate-in">
            <strong>Answer:</strong> Because paper doesn't emit light! If you mix Red, Green, and Blue paint, you don't get white lightâ€”you get a muddy dark brown because the paint absorbs almost all the light hitting it. To get colors on paper, we need to subtract specific wavelengths from white ambient light.
        </div>
        <button class="reveal-button" onclick="revealAnswer('stopthink-answer')">Reveal Answer</button>
    </div>

    <div class="continue-button" onclick="showNextSection(17)">Continue</div>
</section>

<!-- SECTION 17: RGB World & Vocab -->
<section id="section17">
    <p>For the majority of this course, since we are dealing with digital images and cameras, we will be living in the <strong>RGB</strong> world.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Bit Depth</h4>
        <p>The number of bits used to indicate the color of a single pixel. Higher bit depth means more possible colors.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(18)">Continue</div>
</section>

<!-- SECTION 18: Review & Reflect -->
<section id="section18">
    <h2>Review and Reflect</h2>
    <p>We've now successfully filled our empty grid with data. We know that every pixel contains numerical values representing light intensity, quantized into discrete steps (usually 0-255).</p>
    <p>We also know that to see color, we stack three of these grids togetherâ€”one for Red, one for Green, and one for Blueâ€”to create the RGB images we see on screens.</p>
    
    <h3>Key Takeaways:</h3>
    <ul>
        <li><strong>Quantization:</strong> Turning continuous reality into discrete integers.</li>
        <li><strong>Additive Color (RGB):</strong> Mixing light to create white (used in screens).</li>
        <li><strong>Subtractive Color (CMY):</strong> Mixing ink to absorb light (used in print).</li>
    </ul>

    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>Scientific cameras sometimes use 10-bit images to capture more detail. What is the maximum pixel value in a 10-bit image?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'No, that\'s for 8-bit images (\\(2^8\\)).')">255</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Close, but that\'s \\(2^9\\).')">512</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! \\(2^{10} = 1024\\) total levels. Since we start counting at 0, the maximum value is 1023.')">1023</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'No, bit depth calculations are based on powers of 2.')">100</div>
        </div>
    </div>
    
    <div class="continue-button" id="continue-after-tyk2" onclick="showNextSection(19)" style="display: none;">Continue</div>
</section>

<!-- SECTION 19: FAQ & Closing -->
<section id="section19">
    <div class="faq-section">
        <h3>Frequently Asked</h3>
        <p><strong>Q: Is pixel value 0 always black and 255 always white?</strong></p>
        <p>A: In standard 'integer' images (like JPEGs or PNGs), yes. 0 is no light (black) and the maximum value (255) is full light (white). However, in some scientific or medical imaging using 'floating point' numbers, 0.0 might be black and 1.0 might be white. But for now, assume 0 is black!</p>
    </div>
    <p>In the next lesson, we will find out why RGB is actually terrible for math, and how we can use better Color Models to help computers see like humans.</p>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">âœ“ Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 19;

updateProgress();
// In case the page is loaded with all sections visible for debugging (not standard flow)
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event && event.target;
    
    if (!nextSectionElement) return;
    
    // Hide the button that was clicked
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    
    // Show next section
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    
    // Show completed button if at end
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    
    // Smooth scroll
    setTimeout(() => { 
        nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); 
    }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
    
    // Only show continue button if answer is correct
    if (!isCorrect) return;
    
    // Reveal continue button logic for TYK sections
    const parentSection = element.closest('section');
    if (parentSection) {
        let continueBtnId = '';
        if (parentSection.id === 'section7') continueBtnId = 'continue-after-tyk1';
        if (parentSection.id === 'section18') continueBtnId = 'continue-after-tyk2';
        
        if (continueBtnId) {
            const continueButton = document.getElementById(continueBtnId);
            if (continueButton && continueButton.style.display === 'none') {
                setTimeout(() => {
                    continueButton.style.display = 'block';
                    continueButton.classList.add('show-with-animation');
                }, 800);
            }
        }
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // IDs adjusted for this specific lesson
                let courseId = 'computer-vision';
                let pathId = 'foundations';
                let moduleId = 'cv-ch2-m1-images-as-data';
                let lessonId = 'cv-ch2-l2-quantizing-light';
                
                if (window.parent.currentRoute) {
                    const route = window.parent.currentRoute;
                    if (route.courseId) courseId = route.courseId;
                    if (route.pathId) pathId = route.pathId;
                    if (route.moduleId) moduleId = route.moduleId;
                    // Use route lessonId if available, otherwise default
                    if (route.lessonId) lessonId = route.lessonId;
                }
                
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = 'âœ… Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv-ch2-l2_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['ðŸŽ‰', 'ðŸŽŠ', 'âœ¨', 'ðŸŒŸ', 'ðŸ’¡', 'ðŸŒˆ', 'ðŸŽ¨'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = 'â—';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = 'ðŸŽ‰ Lesson Completed! Great Job! ðŸŽ‰';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    
    // Check local storage first
    const isCompleted = localStorage.getItem('lesson_cv-ch2-l2_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = 'âœ… Completed!';
    }
    
    // Check parent tracker if available
    if (window.parent && window.parent.ProgressTracker) {
        // ... (Logic duplicates toggleCompleted IDs, omitted for brevity but conceptually present)
    }
});
</script>
</body>
</html>