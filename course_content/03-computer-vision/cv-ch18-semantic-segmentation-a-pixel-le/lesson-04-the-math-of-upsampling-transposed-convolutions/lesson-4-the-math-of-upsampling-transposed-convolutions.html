<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<title>The Math of Upsampling – Transposed Convolutions</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
    background: #ffffff;
    min-height: 100vh;
    color: #2d3748;
    line-height: 1.6;
}

/* Progress Bar */
.progress-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 4px;
    background: rgba(0, 0, 0, 0.1);
    z-index: 1000;
}

.progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
    width: 0%;
    transition: width 0.5s ease;
    box-shadow: 0 0 10px rgba(79, 172, 254, 0.5);
}

/* Main Container */
.lesson-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 40px 20px;
}

/* Sections */
section {
    background: transparent;
    margin-bottom: 30px;
    padding: 20px 0;
    display: none;
    opacity: 0;
    transition: all 0.6s ease;
    transform: translateY(20px);
    text-align: center;
}

section.visible {
    display: block;
    opacity: 1;
    transform: translateY(0);
}

/* Reset text alignment */
section > *:not(.continue-button) {
    text-align: left;
}

/* Typography */
h1 {
    font-size: 2.5rem;
    font-weight: 700;
    color: #2d3748;
    margin-bottom: 1.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    line-height: 1.2;
}

h2 {
    font-size: 2rem;
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 1.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #4a5568;
    margin-bottom: 1rem;
}

p {
    font-size: 1.125rem;
    line-height: 1.7;
    color: #4a5568;
    margin-bottom: 1.5rem;
    text-align: left;
}

ul, ol {
    margin-left: 1.5rem;
    margin-bottom: 1.5rem;
    text-align: left;
}

li {
    font-size: 1.125rem;
    line-height: 1.7;
    color: #4a5568;
    margin-bottom: 0.5rem;
}

strong {
    color: #2d3748;
    font-weight: 600;
}

em {
    color: #667eea;
    font-style: normal;
    font-weight: 500;
}

/* Placeholders */
.image-placeholder, .interactive-placeholder, .visual-placeholder {
    margin: 1.5rem 0;
}

.image-placeholder img {
    width: 100%;
    height: auto;
    border-radius: 12px;
    display: block;
    box-shadow: 0 10px 30px rgba(15, 23, 42, 0.15);
}

.image-caption {
    margin-top: 0.75rem;
    font-size: 0.95rem;
    color: #94a3b8;
    text-align: center;
}

.placeholder-box {
    width: 100%;
    min-height: 220px;
    padding: 20px;
    border: 2px dashed #cbd5e1;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #94a3b8;
    background: #f8fafc;
    font-weight: 600;
    text-align: center;
}

.lesson-container img {
    max-width: 100%;
    width: 100%;
    height: auto;
    display: block;
}

/* Content Boxes */
.why-it-matters, .vocab-section, .check-your-knowledge, .test-your-knowledge, .faq-section {
    margin: 2rem 0;
    padding: 2rem;
    border-radius: 8px;
    border-left: 4px solid;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    text-align: left;
}

.why-it-matters {
    background: linear-gradient(135deg, #ffeef7 0%, #fff0f8 100%);
    border-left-color: #f093fb;
    box-shadow: 0 10px 30px rgba(240, 147, 251, 0.1);
}

.vocab-section {
    background: linear-gradient(135deg, #e6f3ff 0%, #f0f8ff 100%);
    border-left-color: #4facfe;
    box-shadow: 0 10px 30px rgba(79, 172, 254, 0.1);
}
.vocab-section h4 {
    color: #2d3748;
    font-size: 1.25rem;
    font-weight: 600;
    margin: 0 0 0.75rem 0;
}

.test-your-knowledge, .check-your-knowledge, .faq-section {
    background: linear-gradient(135deg, #eafaf1 0%, #f0fcf4 100%);
    border-left-color: #68d391;
    box-shadow: 0 10px 30px rgba(104, 211, 145, 0.1);
}
.test-your-knowledge h3, .check-your-knowledge h3, .faq-section h3 {
    color: #10b981;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    font-weight: 700;
    margin-bottom: 1rem;
}
.test-your-knowledge h4, .check-your-knowledge h4, .faq-section h4 {
    color: #2d3748;
    font-size: 1.25rem;
    font-weight: 600;
    margin: 1.5rem 0 1rem 0;
}

/* Buttons */
.continue-button, .reveal-button, .check-button {
    display: inline-block;
    padding: 16px 32px;
    margin-top: 2rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 50px;
    text-decoration: none;
    cursor: pointer;
    border: none;
    font-size: 1rem;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
    position: relative;
    overflow: hidden;
}

.continue-button:hover, .reveal-button:hover, .check-button:hover {
    transform: translateY(-3px);
    box-shadow: 0 15px 40px rgba(102, 126, 234, 0.4);
}

.continue-button.show-with-animation {
    opacity: 0;
    transform: translateY(20px);
    animation: fadeInUp 0.6s ease-out forwards;
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

/* Multiple Choice */
.multiple-choice { margin: 1.5rem 0; text-align: left; }
.choice-option {
    display: block;
    margin: 1rem 0;
    padding: 1.5rem;
    background: #f8fafc;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;
    font-weight: 500;
    position: relative;
    overflow: hidden;
}
.choice-option::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 0;
}
.choice-option:hover { transform: translateX(5px); border-color: rgba(102,126,234,0.3); box-shadow: 0 10px 30px rgba(102,126,234,0.15); }
.choice-option:hover::before { opacity: 0.05; }
.choice-option.selected, .choice-option.correct { background: linear-gradient(135deg, #eafaf1 0%, #f0fcf4 100%); border-color: #68d391; color: #2d3748; }
.choice-option.incorrect { background: linear-gradient(135deg, #fef2f2 0%, #fef7f7 100%); border-color: #f87171; color: #2d3748; }
.choice-explanation { display: none; margin-top: 1rem; padding: 1rem; background: #f1f5f9; border-radius: 8px; font-size: 0.95rem; position: relative; z-index: 1; }

/* Mark as Completed Button */
.mark-completed-button {
    display: none;
    width: 100%;
    max-width: 400px;
    margin: 40px auto 20px auto;
    padding: 16px 32px;
    background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
    color: white;
    border: none;
    border-radius: 50px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 4px 20px rgba(72, 187, 120, 0.3);
    text-align: center;
    text-decoration: none;
}
.mark-completed-button.show { display: block; }
.mark-completed-button.completed { background: linear-gradient(135deg, #94a3b8 0%, #64748b 100%); cursor: default; }

/* Success Message and Confetti */
.success-message {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    padding: 20px 30px;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    box-shadow: 0 10px 25px rgba(40, 167, 69, 0.3);
    z-index: 10000;
    opacity: 0;
    animation: success-popup 2.5s ease-out;
    pointer-events: none;
}
@keyframes success-popup {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    40% { transform: translate(-50%, -50%) scale(1); }
    80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
}
.confetti-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; overflow: hidden; }
.confetti { position: absolute; font-size: 20px; animation: confetti-fall 3s linear infinite; }
@keyframes confetti-fall { 0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }

/* Animations for reveals */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
.animate-in { animation: fadeIn 0.5s ease-out; }

/* Responsive */
@media (max-width: 768px) {
    .lesson-container { padding: 20px 15px; }
    section { padding: 15px 0; margin-bottom: 20px; }
    h1 { font-size: 2rem; }
    h2 { font-size: 1.75rem; }
    p, li { font-size: 1rem; }
    .continue-button { width: 100%; }
}
</style>
<script>
window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">

<section id="section1" class="visible">
    <div class="image-placeholder">
        <img src="images/1.jpg" alt="Split view showing tiny feature map on the left and full segmentation mask on the right">
    </div>
    <h1>The Math of Upsampling – Transposed Convolutions</h1>
    <p>Welcome back! In our previous lesson, we looked at the Encoder-Decoder structure. We saw how the Encoder acts like a funnel, crushing the image down to extract the <em>meaning</em> (semantics) while sacrificing the <em>details</em> (spatial resolution).</p>
    <p>Now, we face the opposite problem. The Decoder needs to take those tiny, semantically rich feature maps and blow them back up to the original image size to create a mask. But how?</p>
    <div class="continue-button" onclick="showNextSection(2)">Continue</div>
</section>

<section id="section2">
    <h2>Standard vs. Learned Resizing</h2>
    <p>You might be thinking, "Why not just resize the image like I do in Photoshop?"</p>
    <div class="continue-button" onclick="showNextSection(3)">Continue</div>
</section>

<section id="section3">
    <p>Standard methods like <strong>Bilinear Interpolation</strong> work by calculating the average of neighboring pixels to fill in the gaps. It's fast, but it's also "dumb." It applies the exact same mathematical formula to a cloud as it does to the sharp edge of a building.</p>
    <div class="continue-button" onclick="showNextSection(4)">Continue</div>
</section>

<section id="section4">
    <p>In semantic segmentation, we don't want a fixed formula. We want our network to <em>learn</em> the best way to upsample. We want it to learn that some edges should be sharp and some textures should be smooth.</p>
    <p>To do this, we use a special operation called the <strong>Transposed Convolution</strong>.</p>
    <div class="continue-button" onclick="showNextSection(5)">Continue</div>
</section>

<section id="section5">
    <h2>Vocabulary Alert: It's NOT Deconvolution</h2>
    <div class="image-placeholder">
        <img src="images/2.jpg" alt="Warning graphic showing deconvolution crossed out and transposed convolution highlighted">
        <p class="image-caption">It isn’t deconvolution—transposed convolution just reverses the spatial direction.</p>
    </div>
    <p>Before we look at the math, we need to clear up a very common point of confusion. You will often hear people refer to this upsampling operation as "Deconvolution." <strong>This is mathematically incorrect.</strong></p>
    <div class="continue-button" onclick="showNextSection(6)">Continue</div>
</section>

<section id="section6">
    <p>In pure mathematics, a "deconvolution" reverses the effects of a convolution—like trying to unscramble an egg to get the raw yolk back.</p>
    <p>A <strong>Transposed Convolution</strong> does not reverse the mathematical operation; it only reverses the <strong>spatial dimensions</strong>. It takes a small input and produces a large output, but the values inside are new, learned projections, not the restored original pixels.</p>
    <div class="continue-button" onclick="showNextSection(7)">Continue</div>
</section>

<section id="section7">
    <h2>The Mechanism: The "Spread"</h2>
    <p>So, how does it work? Think of a standard convolution as a "collection" mechanism: it looks at a \(3 \times 3\) area and summarizes it into a single number (Many-to-One).</p>
    <p>A Transposed Convolution is a "broadcasting" or "spreading" mechanism (One-to-Many). It takes a single pixel from the input and projects it onto a larger area in the output, weighted by a kernel.</p>
    <div class="continue-button" onclick="showNextSection(8)">Continue</div>
</section>

<section id="section8">
    <p>Let's walk through the math step-by-step using a \(2 \times 2\) input and a \(2 \times 2\) kernel. Suppose we have this Input and this Kernel:</p>
    <p>$$ \text{Input} = \begin{bmatrix} 0 & 1 \\ 2 & 3 \end{bmatrix} \quad \text{Kernel} = \begin{bmatrix} 1 & 2 \\ 4 & 2 \end{bmatrix} $$</p>
    <p>For the first pixel (top-left, value \(0\)), we multiply the entire kernel by \(0\) and place it on the output grid:</p>
    <p>$$ 0 \times \begin{bmatrix} 1 & 2 \\ 4 & 2 \end{bmatrix} = \begin{bmatrix} 0 & 0 \\ 0 & 0 \end{bmatrix} $$</p>
    <div class="continue-button" onclick="showNextSection(9)">Continue</div>
</section>

<section id="section9">
    <p>Now, we slide over to the next pixel (top-right, value \(1\)). We multiply the kernel by \(1\). Because we are moving one step in the input, we move one step in the output (assuming stride 1).</p>
    <p>$$ 1 \times \begin{bmatrix} 1 & 2 \\ 4 & 2 \end{bmatrix} = \begin{bmatrix} 1 & 2 \\ 4 & 2 \end{bmatrix} $$</p>
    <p>Here is the critical part: <strong>Handling Overlaps</strong>. Unlike standard convolution where we sum inputs to get one output, here we sum the <em>outputs</em> where they overlap. The projections from the first pixel and the second pixel land on top of each other in the middle column.</p>
    <div class="image-placeholder">
        <img src="images/3.jpg" alt="Kernel projections overlapping on an output grid to illustrate summation">
        <p class="image-caption">Each input pixel spreads a kernel; overlapping spreads add up to form detail.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(10)">Continue</div>
</section>

<section id="section10">
    <h2>Interactive: The Learnable Upsampler</h2>
    <p>This concept is much easier to grasp when you can see the projection happening.</p>
    <!-- Interactive Module: Transposed Convolution Calculator -->
<div class="interactive-upsampler-container">
    <div class="canvas-wrapper">
        <canvas id="transposedConvCanvas"></canvas>
        <div id="mathTooltip" class="math-tooltip"></div>
    </div>
    <div class="controls-hint">
        <span class="hint-text">💡 Hover over grid lines to see how values overlap and add up.</span>
    </div>
</div>

<style>
.interactive-upsampler-container {
    background: #f8fafc;
    border: 2px solid #e2e8f0;
    border-radius: 12px;
    padding: 20px;
    margin: 2rem 0;
    text-align: center;
    position: relative;
    user-select: none;
}

.canvas-wrapper {
    position: relative;
    display: inline-block;
    width: 100%;
    max-width: 700px;
}

canvas#transposedConvCanvas {
    width: 100%;
    height: 350px; /* Base height */
    display: block;
    margin: 0 auto;
    cursor: crosshair;
}

.math-tooltip {
    position: absolute;
    display: none;
    background: rgba(45, 55, 72, 0.95);
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    font-size: 0.9rem;
    font-weight: 600;
    pointer-events: none;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    white-space: nowrap;
    z-index: 10;
    transform: translate(-50%, -120%); /* Center above point */
    border: 1px solid rgba(255,255,255,0.2);
}

.math-tooltip::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    margin-left: -5px;
    border-width: 5px;
    border-style: solid;
    border-color: rgba(45, 55, 72, 0.95) transparent transparent transparent;
}

.controls-hint {
    margin-top: 10px;
}

.hint-text {
    font-size: 0.9rem;
    color: #718096;
    background: #edf2f7;
    padding: 4px 12px;
    border-radius: 20px;
}
</style>

<script>
(function() {
    const canvas = document.getElementById('transposedConvCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('mathTooltip');
    const container = canvas.closest('.canvas-wrapper');
    const parentSection = canvas.closest('section');
    const baseHeight = 350;

    // Data Definition
    const inputGrid = [
        [0, 1],
        [2, 3]
    ];
    
    const kernel = [
        [1, 2],
        [4, 2]
    ];
    
    // Output dimensions (Input * Stride + Kernel - 2*Padding) -> 2*1 + 2 - 0 = 3 calculated manually 
    // for this specific 2x2 -> 3x3 scenario (stride 1, valid padding equivalent)
    const outputRows = 3;
    const outputCols = 3;

    // Layout Configuration
    let dpr = window.devicePixelRatio || 1;
    const layout = {
        input: { x: 0, y: 0, s: 0, rows: 2, cols: 2 },
        kernel: { x: 0, y: 0, s: 0, rows: 2, cols: 2 },
        output: { x: 0, y: 0, s: 0, rows: 3, cols: 3 }
    };

    // Interaction State
    let activeInputs = []; // Array of {r, c}
    let mousePos = { x: 0, y: 0 };

    // Colors
    const colors = {
        gridBorder: '#cbd5e1',
        inputFill: '#ffffff',
        inputActive: '#ebf8ff', // light blue
        inputBorderActive: '#4299e1',
        kernelFill: '#fff5f7', // light pink
        kernelBorder: '#ed64a6',
        outputFill: '#f0fff4', // light green
        outputHighlight: '#9ae6b4',
        outputOverlap: '#faf089', // yellow
        text: '#2d3748',
        arrow: 'rgba(102, 126, 234, 0.4)'
    };

    function resize() {
        if (!container) return;
        const rect = container.getBoundingClientRect();
        const parentWidth = container.parentElement ? container.parentElement.clientWidth : 0;
        const fallbackWidth = canvas.parentElement ? canvas.parentElement.clientWidth : 0;
        const width = rect.width || parentWidth || fallbackWidth || 600;
        const height = baseHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        if (typeof ctx.resetTransform === 'function') {
            ctx.resetTransform();
        } else {
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }
        ctx.scale(dpr, dpr);
        canvas.style.width = '100%';
        canvas.style.height = `${height}px`;

        // Calculate layout positions
        const w = width;
        const h = height;
        const cellBase = Math.min(w / 12, 50);

        // Position Input (Left)
        layout.input.s = cellBase;
        layout.input.x = w * 0.15;
        layout.input.y = h / 2 - (layout.input.rows * cellBase) / 2;

        // Position Kernel (Middle Top)
        layout.kernel.s = cellBase * 0.8;
        layout.kernel.x = w * 0.45;
        layout.kernel.y = h * 0.25;

        // Position Output (Right)
        layout.output.s = cellBase;
        layout.output.x = w * 0.7;
        layout.output.y = h / 2 - (layout.output.rows * cellBase) / 2;
        
        draw();
    }

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    // Logic: Identify which input pixels are "active" based on mouse
    function updateActiveState(pos) {
        activeInputs = [];
        
        const ls = layout.input.s;
        const startX = layout.input.x;
        const startY = layout.input.y;
        const gridW = layout.input.cols * ls;
        const gridH = layout.input.rows * ls;

        // Bounding box check with margin
        if (pos.x < startX - 20 || pos.x > startX + gridW + 20 ||
            pos.y < startY - 20 || pos.y > startY + gridH + 20) {
            tooltip.style.display = 'none';
            return;
        }

        // Fuzzy logic: Check distance to center of each cell
        // If closer to border, activate neighbors
        const threshold = ls * 0.65; // Overlap radius

        for(let r=0; r<2; r++) {
            for(let c=0; c<2; c++) {
                const cx = startX + c*ls + ls/2;
                const cy = startY + r*ls + ls/2;
                const dist = Math.sqrt(Math.pow(pos.x - cx, 2) + Math.pow(pos.y - cy, 2));
                
                if (dist < threshold) {
                    activeInputs.push({r, c, val: inputGrid[r][c]});
                }
            }
        }
    }

    // Math: Calculate Output based strictly on ACTIVE inputs
    function calculateOutput() {
        // Initialize 3x3 output with details
        let output = [];
        for(let r=0; r<3; r++) {
            let row = [];
            for(let c=0; c<3; c++) {
                row.push({ val: 0, terms: [], active: false });
            }
            output.push(row);
        }

        // Project each active input
        activeInputs.forEach(input => {
            // Where does this input's 2x2 kernel land on the 3x3 output?
            // Input(0,0) -> Output(0,0) to (1,1)
            // Input(0,1) -> Output(0,1) to (1,2)
            // Input(1,0) -> Output(1,0) to (2,1)
            // Input(1,1) -> Output(1,1) to (2,2)
            
            const startR = input.r;
            const startC = input.c;

            for(let kr=0; kr<2; kr++) {
                for(let kc=0; kc<2; kc++) {
                    const outR = startR + kr;
                    const outC = startC + kc;
                    
                    const kVal = kernel[kr][kc];
                    const product = input.val * kVal;
                    
                    output[outR][outC].val += product;
                    output[outR][outC].terms.push(product); // Store the term for tooltip
                    output[outR][outC].active = true;
                }
            }
        });

        return output;
    }

    function drawGrid(ctx, cfg, data, isOutput = false, outputMeta = null) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.font = "bold 16px -apple-system, sans-serif";

        for(let r=0; r<cfg.rows; r++) {
            for(let c=0; c<cfg.cols; c++) {
                const x = cfg.x + c * cfg.s;
                const y = cfg.y + r * cfg.s;
                
                // Determine styling
                let fill = colors.inputFill;
                let stroke = colors.gridBorder;
                let lineWidth = 2;
                let value = data[r][c];
                
                // Input Styling
                if (!isOutput) {
                    // Check if this specific cell is active
                    const isActive = activeInputs.some(i => i.r === r && i.c === c);
                    if (isActive) {
                        fill = colors.inputActive;
                        stroke = colors.inputBorderActive;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "rgba(66, 153, 225, 0.4)";
                    }
                } 
                // Output Styling
                else if (outputMeta) {
                    const cell = outputMeta[r][c];
                    if (cell.active) {
                        fill = cell.terms.length > 1 ? colors.outputOverlap : colors.outputHighlight;
                        stroke = cell.terms.length > 1 ? '#d69e2e' : '#48bb78';
                        value = cell.val;
                    } else {
                        value = ''; // Don't show 0s for inactive
                    }
                }
                
                // Kernel Styling (Generic)
                if (cfg === layout.kernel) {
                    fill = colors.kernelFill;
                    stroke = colors.kernelBorder;
                }

                ctx.beginPath();
                ctx.roundRect(x, y, cfg.s - 4, cfg.s - 4, 6);
                ctx.fillStyle = fill;
                ctx.fill();
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = stroke;
                ctx.stroke();
                
                ctx.shadowBlur = 0; // Reset shadow

                // Text
                ctx.fillStyle = colors.text;
                if (value !== '') {
                    ctx.fillText(value, x + cfg.s/2 - 2, y + cfg.s/2 - 2);
                }
            }
        }
    }

    function drawConnections(outputData) {
        if (activeInputs.length === 0) return;

        // Draw Kernel Label
        ctx.fillStyle = colors.kernelBorder;
        ctx.font = "bold 14px sans-serif";
        ctx.fillText("Kernel × Value", layout.kernel.x + layout.kernel.s, layout.kernel.y - 15);

        // Tooltip Logic
        let maxOverlap = 0;
        let tooltipTarget = null;

        // Find the "hottest" cell (most overlaps)
        for(let r=0; r<3; r++) {
            for(let c=0; c<3; c++) {
                const cell = outputData[r][c];
                if (cell.terms.length > maxOverlap) {
                    maxOverlap = cell.terms.length;
                    tooltipTarget = { r, c, terms: cell.terms, val: cell.val };
                }
                // Fallback: if no overlap, just show first active
                else if (cell.active && !tooltipTarget) {
                    tooltipTarget = { r, c, terms: cell.terms, val: cell.val };
                }
            }
        }

        // Render Tooltip
        if (tooltipTarget) {
            const tx = layout.output.x + tooltipTarget.c * layout.output.s + layout.output.s/2;
            const ty = layout.output.y + tooltipTarget.r * layout.output.s;
            
            tooltip.style.display = 'block';
            tooltip.style.left = `${tx}px`;
            tooltip.style.top = `${ty}px`;

            if (tooltipTarget.terms.length > 1) {
                // Show addition: "4 + 1 = 5"
                tooltip.innerHTML = `${tooltipTarget.terms.join(' + ')} = <span style="color:#68d391">${tooltipTarget.val}</span>`;
            } else {
                // Show operation: "1 * 4 = 4"
                // Reverse engineer which input caused this? 
                // Simplified: just show value
                tooltip.innerHTML = `Val: ${tooltipTarget.val}`;
            }
        } else {
            tooltip.style.display = 'none';
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Labels
        ctx.font = "bold 18px -apple-system, sans-serif";
        ctx.fillStyle = "#4a5568";
        ctx.fillText("Input", layout.input.x + layout.input.s, layout.input.y - 20);
        ctx.fillText("Output", layout.output.x + (layout.output.cols*layout.output.s)/2, layout.output.y - 20);

        // 1. Draw Inputs
        drawGrid(ctx, layout.input, inputGrid);

        // 2. Draw Kernel
        drawGrid(ctx, layout.kernel, kernel);

        // 3. Calculate & Draw Output
        const outputData = calculateOutput();
        drawGrid(ctx, layout.output, null, true, outputData);

        // 4. Draw Connections/Tooltips
        drawConnections(outputData);
    }

    // Event Listeners
    canvas.addEventListener('mousemove', (e) => {
        mousePos = getMousePos(e);
        updateActiveState(mousePos);
        draw();
    });

    canvas.addEventListener('mouseleave', () => {
        activeInputs = [];
        tooltip.style.display = 'none';
        draw();
    });

    window.addEventListener('resize', resize);
    
    function handleSectionVisibility() {
        if (!parentSection) return;
        if (parentSection.classList.contains('visible')) {
            resize();
            return;
        }
        const observer = new MutationObserver(() => {
            if (parentSection.classList.contains('visible')) {
                resize();
                observer.disconnect();
            }
        });
        observer.observe(parentSection, { attributes: true, attributeFilter: ['class'] });
    }
    
    // Initial Render
    resize();
    handleSectionVisibility();

})();
</script>
    <p>Hover over the pixels in the input grid on the left. Watch how each input pixel projects a "shadow" of the kernel onto the output grid. Notice the bright regions—those are the overlaps where the values are summed together.</p>
    <div class="continue-button" onclick="showNextSection(11)">Continue</div>
</section>

<section id="section11">
    <h2>Comparing Operations</h2>
    <p>Let's summarize the difference between the two main operations in our network.</p>
    <ul>
        <li><strong>Standard Convolution:</strong> Reduces spatial size. Takes a patch of pixels \(\to\) returns a single value.</li>
        <li><strong>Transposed Convolution:</strong> Increases spatial size. Takes a single value \(\to\) returns a patch of pixels.</li>
    </ul>
    <!-- Interactive Module: Convolution vs Transposed Convolution -->
<div class="interactive-module-container">
  <canvas id="convComparisonCanvas"></canvas>
  <div class="controls-hint">
      <span class="hint-text">Animation playing automatically. Hover/Touch to control manually.</span>
      <input type="range" min="0" max="100" value="0" class="scrubber" id="animScrubber">
  </div>
</div>

<style>
.interactive-module-container {
  background: #f8fafc;
  border: 2px solid #e2e8f0;
  border-radius: 12px;
  padding: 20px;
  margin: 2rem 0;
  text-align: center;
  position: relative;
  overflow: hidden;
}

canvas#convComparisonCanvas {
  width: 100%;
  height: 300px;
  display: block;
  margin: 0 auto;
}

.controls-hint {
  margin-top: 15px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.hint-text {
  font-size: 0.85rem;
  color: #94a3b8;
  font-weight: 500;
}

.scrubber {
  width: 80%;
  max-width: 400px;
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  background: #e2e8f0;
  border-radius: 5px;
  outline: none;
  opacity: 0.7;
  transition: opacity .2s;
}

.scrubber:hover { opacity: 1; }

.scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #667eea;
  cursor: pointer;
}

.scrubber::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #667eea;
  cursor: pointer;
}
</style>

<script>
(function() {
  const canvas = document.getElementById('convComparisonCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  const slider = document.getElementById('animScrubber');
  const container = canvas.closest('.interactive-module-container');
  const parentSection = canvas.closest('section');
  const baseHeight = 300;
  
  // State
  let isHovering = false;
  let autoProgress = 0;
  let dpr = window.devicePixelRatio || 1;
  
  // Colors matches the lesson theme
  const colors = {
      inputBase: '#cbd5e1',     // Slate 300
      inputActive: '#4299e1',   // Blue 400
      outputBase: '#cbd5e1',    // Slate 300
      outputActive: '#9f7aea',  // Purple 400
      line: 'rgba(102, 126, 234, 0.5)',
      text: '#4a5568'
  };

  function resize() {
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const parentWidth = container.parentElement ? container.parentElement.clientWidth : 0;
      const fallbackWidth = canvas.parentElement ? canvas.parentElement.clientWidth : 0;
      const width = rect.width || parentWidth || fallbackWidth || 600;
      const height = baseHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      if (typeof ctx.resetTransform === 'function') {
          ctx.resetTransform();
      } else {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
      }
      ctx.scale(dpr, dpr);
      canvas.style.width = '100%';
      canvas.style.height = `${height}px`;
  }

  // Grid Drawing Helper
  function drawGrid(centerX, centerY, rows, cols, cellSize, isActive, activeColor) {
      const totalW = cols * cellSize;
      const totalH = rows * cellSize;
      const startX = centerX - totalW / 2;
      const startY = centerY - totalH / 2;
      
      const positions = [];

      ctx.lineWidth = 2;
      
      for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
              const x = startX + c * cellSize;
              const y = startY + r * cellSize;
              
              ctx.fillStyle = isActive ? activeColor : colors.inputBase;
              ctx.strokeStyle = '#ffffff';
              
              // Draw Cell
              ctx.beginPath();
              ctx.roundRect(x, y, cellSize - 2, cellSize - 2, 4);
              ctx.fill();
              ctx.stroke();

              // Store center point for lines
              positions.push({
                  x: x + cellSize/2, 
                  y: y + cellSize/2
              });
          }
      }
      return positions;
  }

  function drawArrow(x, y, text) {
      ctx.fillStyle = colors.text;
      ctx.font = "bold 14px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText(text, x, y);
  }

  function drawScene() {
      // Clear
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
      
      const w = canvas.width / dpr;
      const h = canvas.height / dpr;
      
      // Split screen
      const leftCenter = w * 0.25;
      const rightCenter = w * 0.75;
      const centerY = h * 0.55; // Push down slightly to make room for titles
      
      // Titles
      ctx.fillStyle = '#2d3748';
      ctx.font = "bold 18px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Standard Convolution", leftCenter, 40);
      ctx.fillText("Transposed Convolution", rightCenter, 40);

      ctx.fillStyle = '#718096';
      ctx.font = "14px -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";
      ctx.fillText("Many to One", leftCenter, 65);
      ctx.fillText("One to Many", rightCenter, 65);

      // Divider
      ctx.beginPath();
      ctx.moveTo(w/2, 20);
      ctx.lineTo(w/2, h - 20);
      ctx.strokeStyle = '#e2e8f0';
      ctx.setLineDash([5, 5]);
      ctx.stroke();
      ctx.setLineDash([]);

      // Determine Animation Progress (0 to 1)
      let progress = isHovering ? (parseInt(slider.value) / 100) : autoProgress;
      
      // Loop logic for auto-play: 
      // 0.0 - 0.2: Pause at start
      // 0.2 - 0.5: Move
      // 0.5 - 0.7: Hold
      // 0.7 - 0.9: Fade out/Reset
      
      let movePhase = 0;
      let opacity = 0;
      let inputActive = false;
      let outputActive = false;

      if (progress < 0.2) {
          movePhase = 0;
          inputActive = true;
      } else if (progress < 0.6) {
          movePhase = (progress - 0.2) / 0.4; // 0 to 1
          opacity = Math.sin(movePhase * Math.PI);
          inputActive = true;
      } else if (progress < 0.8) {
          movePhase = 1;
          opacity = 0;
          inputActive = false;
          outputActive = true;
      } else {
          // reset phase
          movePhase = 0;
          inputActive = false;
          outputActive = false;
      }

      // --- LEFT SIDE: CONVOLUTION (3x3 -> 1x1) ---
      const cellGap = 50; // space between grids
      const cellSize = 30;
      
      // Input Grid (3x3)
      const leftInputPos = drawGrid(leftCenter - 60, centerY, 3, 3, cellSize, inputActive, colors.inputActive);
      
      // Output Grid (1x1)
      const leftOutputPos = drawGrid(leftCenter + 60, centerY, 1, 1, cellSize, outputActive, colors.outputActive);
      
      // Draw Connecting Lines (Converging)
      if (movePhase > 0) {
          ctx.strokeStyle = `rgba(102, 126, 234, ${opacity})`;
          ctx.lineWidth = 2;
          const target = leftOutputPos[0];
          
          leftInputPos.forEach(start => {
              ctx.beginPath();
              const currX = start.x + (target.x - start.x) * movePhase;
              const currY = start.y + (target.y - start.y) * movePhase;
              ctx.moveTo(start.x, start.y);
              ctx.lineTo(currX, currY);
              ctx.stroke();
              
              // Draw little dot at tip
              ctx.fillStyle = `rgba(102, 126, 234, ${opacity})`;
              ctx.beginPath();
              ctx.arc(currX, currY, 3, 0, Math.PI*2);
              ctx.fill();
          });
      }

      // --- RIGHT SIDE: TRANSPOSED (1x1 -> 3x3) ---
      
      // Input Grid (1x1)
      const rightInputPos = drawGrid(rightCenter - 60, centerY, 1, 1, cellSize, inputActive, colors.inputActive);
      
      // Output Grid (3x3)
      const rightOutputPos = drawGrid(rightCenter + 60, centerY, 3, 3, cellSize, outputActive, colors.outputActive);
      
      // Draw Connecting Lines (Diverging)
      if (movePhase > 0) {
          ctx.strokeStyle = `rgba(102, 126, 234, ${opacity})`;
          ctx.lineWidth = 2;
          const start = rightInputPos[0];
          
          rightOutputPos.forEach(target => {
              ctx.beginPath();
              const currX = start.x + (target.x - start.x) * movePhase;
              const currY = start.y + (target.y - start.y) * movePhase;
              ctx.moveTo(start.x, start.y);
              ctx.lineTo(currX, currY);
              ctx.stroke();

              // Draw little dot at tip
              ctx.fillStyle = `rgba(102, 126, 234, ${opacity})`;
              ctx.beginPath();
              ctx.arc(currX, currY, 3, 0, Math.PI*2);
              ctx.fill();
          });
      }
  }

  function animate() {
      if (!isHovering) {
          autoProgress += 0.005;
          if (autoProgress > 1) autoProgress = 0;
          slider.value = autoProgress * 100;
      }
      drawScene();
      requestAnimationFrame(animate);
  }

  // Event Listeners
  window.addEventListener('resize', resize);
  
  function handleSectionVisibility() {
      if (!parentSection) return;
      if (parentSection.classList.contains('visible')) {
          resize();
          return;
      }
      const observer = new MutationObserver(() => {
          if (parentSection.classList.contains('visible')) {
              resize();
              observer.disconnect();
          }
      });
      observer.observe(parentSection, { attributes: true, attributeFilter: ['class'] });
  }
  
  // Slider Interaction
  slider.addEventListener('mousedown', () => isHovering = true);
  slider.addEventListener('touchstart', () => isHovering = true);
  
  slider.addEventListener('mouseup', () => {
      isHovering = false;
      autoProgress = parseInt(slider.value) / 100;
  });
  slider.addEventListener('touchend', () => {
      isHovering = false;
      autoProgress = parseInt(slider.value) / 100;
  });
  
  slider.addEventListener('input', () => {
      // Just allows the draw loop to pick up the value
  });

  // Hover Interaction for Canvas
  canvas.addEventListener('mouseenter', () => isHovering = true);
  canvas.addEventListener('mouseleave', () => {
      isHovering = false;
      autoProgress = parseInt(slider.value) / 100;
  });
  
  // Init
  resize();
  handleSectionVisibility();
  animate();

})();
</script>
    <div class="check-your-knowledge">
        <h3>Stop and Think</h3>
        <h4>We mentioned earlier that Transposed Convolution is "learnable," unlike Bilinear Interpolation. Why is this specific feature so important for segmentation masks?</h4>
        <div id="stop-think-answer" style="display:none;" class="animate-in">
            <strong>Answer:</strong> Bilinear interpolation just smooths things out. It blurs edges. A Transposed Convolution has weights (the Kernel) that are updated during training. This means the network can learn specific patterns—like how to maintain a sharp, vertical edge for a building, or a curved edge for a wheel—while it upsamples.
        </div>
        <button class="reveal-button" onclick="revealAnswer('stop-think-answer')">Reveal Answer</button>
    </div>
    <div class="continue-button" onclick="showNextSection(12)">Continue</div>
</section>

<section id="section12">
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Transposed Convolution</h4>
        <p>An operation used in deep learning to upsample feature maps. It works by broadcasting each input element to a region defined by the kernel size, summing the overlaps. It is the primary engine for increasing spatial resolution in segmentation networks.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(13)">Continue</div>
</section>

<section id="section13">
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Bilinear Interpolation</h4>
        <p>A standard, non-learnable method for resizing images that estimates new pixel values by taking the weighted average of the four nearest neighbors.</p>
    </div>
    <div class="why-it-matters">
        <h3>Why It Matters</h3>
        <p>Without Transposed Convolutions, the Decoder would just be a blurry mess. This operation allows us to take the deep, abstract "understanding" of the image (from the Encoder) and paint it back onto the screen with high-resolution detail.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(14)">Continue</div>
</section>

<section id="section14">
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>In a Transposed Convolution, what happens when the "projections" from two adjacent input pixels land on the same output pixel?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Averaging is common in interpolation, but not here. In Transposed Convolution, the overlapping signals accumulate.')">The values are averaged.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! The contributions from the overlapping kernel projections are added together.')">The values are summed.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Max Pooling is used to reduce size in the Encoder. Here we are combining information, not filtering it.')">The maximum value is taken (Max Pooling).</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'No, both pixels contribute information to that spatial location.')">The second value overwrites the first.</div>
        </div>
    </div>
    <div class="continue-button" onclick="showNextSection(15)">Continue</div>
</section>

<section id="section15">
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>Which of the following statements is TRUE regarding "Deconvolution" in the context of Deep Learning?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'This is a common misconception. The information lost during pooling (in the Encoder) is gone forever. We cannot mathematically invert the process to get the exact original pixels back.')">It acts as the mathematical inverse of a convolution, perfectly restoring the original input.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Bilinear interpolation is fixed; this operation is learnable.')">It is a synonym for Bilinear Interpolation.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Spot on. While you will see the term used in some papers or libraries, it is technically a misnomer.')">It is a misleading name often used for Transposed Convolution.</div>
        </div>
    </div>
    <div class="continue-button" id="continue-after-test-knowledge" onclick="showNextSection(16)" style="display:none;">Continue</div>
</section>

<section id="section16">
    <div class="faq-section">
        <h3>Frequently Asked Questions</h3>
        <h4>Does Transposed Convolution restore the exact original pixels lost during pooling?</h4>
        <p>No. Once we downsample (pool) an image, the original fine-grained pixel data is discarded to save memory and increase the receptive field.</p>
        <p>The Transposed Convolution "hallucinates" or reconstructs the details based on the learned weights. It uses the semantic context (e.g., "this is a car wheel") to generate pixels that <em>look</em> like a high-resolution car wheel, but it is not mathematically restoring the original pixels from the camera.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(17)">Continue</div>
</section>

<section id="section17">
    <h2>Review and Reflect</h2>
    <p>You've now unlocked the mechanism that makes upsampling possible.</p>
    <p>In this lesson, we moved beyond simple image resizing and learned about <strong>Transposed Convolutions</strong>.</p>
    <ul>
        <li>We established that "Deconvolution" is a misleading name.</li>
        <li>We walked through the math of projecting single pixels into larger regions using a kernel.</li>
        <li>We saw how overlapping regions are <strong>summed</strong> to build the final output.</li>
    </ul>
    <p>Now we have the pieces: The Encoder (to understand context) and the Decoder (to restore size). In the next lesson, we will combine these into the most famous segmentation architecture of all: the <strong>U-Net</strong>.</p>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">✓ Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 17;

updateProgress();
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event && event.target;
    if (!nextSectionElement) return;
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    setTimeout(() => { nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
    
    // Only show continue button on the last quiz section if it was hidden
    const parentSection = element.closest('section');
    if (parentSection && parentSection.id === 'section15') {
        const continueButton = document.getElementById('continue-after-test-knowledge');
        if (continueButton && continueButton.style.display === 'none') {
            setTimeout(() => {
                continueButton.style.display = 'block';
                continueButton.classList.add('show-with-animation');
            }, 800);
        }
    }
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        // Attempt LMS communication
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // These IDs should ideally be dynamic, but setting based on context
                let courseId = 'computer-vision';
                let pathId = 'segmentation';
                let moduleId = 'upsampling';
                let lessonId = 'transposed-convolutions';
                
                // Fallback to URL params
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('course')) courseId = urlParams.get('course');
                if (urlParams.get('path')) pathId = urlParams.get('path');
                if (urlParams.get('module')) moduleId = urlParams.get('module');
                if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
                
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = '✅ Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv_transposed_conv_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['🎉', '🎊', '✨', '🌟', '🎈', '🏆', '👏', '🥳'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = '●';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = '🎉 Lesson Completed! Great Job! 🎉';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    
    // Check local storage for completion
    const isCompleted = localStorage.getItem('lesson_cv_transposed_conv_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = '✅ Completed!';
    }
});
</script>
</body>
</html>