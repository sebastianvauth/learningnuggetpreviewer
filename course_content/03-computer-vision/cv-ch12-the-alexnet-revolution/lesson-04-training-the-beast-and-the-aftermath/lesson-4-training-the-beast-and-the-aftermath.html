<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<link rel="stylesheet" href="../../styles/lesson.css">
<title>Training the Beast & The Aftermath</title>
<script>
window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">

<!-- SECTION 1: Introduction -->
<section id="section1" class="visible">
    <div class="image-placeholder">
        <img src="images/1.jpg" alt="Neural network architecture design blueprint versus engineering effort and training construction site">
        <p class="image-caption">From blueprint to reality: designing is one thing, training is another.</p>
    </div>
    <h1>Training the Beast</h1>
    <p>Having a blueprint (the architecture) isn't enough. You need to actually build the house. In the previous lesson, we mapped out the neurons and layers of AlexNet. Now, we face the reality of 2012: How do you train a network with 60 million parameters without it memorizing the data (overfitting) or crashing your hardware?</p>
    <div class="continue-button" onclick="showNextSection(2)">Continue</div>
</section>

<!-- SECTION 2: Intro Pt 2 -->
<section id="section2">
    <p>Training AlexNet wasn't just about pressing 'Run'. It required specific engineering feats to handle memory limitations and aggressive regularization to force the model to learn general features rather than just memorizing the training images.</p>
    <div class="continue-button" onclick="showNextSection(3)">Continue</div>
</section>

<!-- SECTION 3: Dropout Intro -->
<section id="section3">
    <h2>The Art of Forgetting: Dropout</h2>
    <p>With 60 million parameters and 650,000 neurons, AlexNet had a massive capacity to learn. In fact, it had <em>too much</em> capacity. Without intervention, the network would simply memorize the training set, leading to severe overfitting.</p>
    <div class="continue-button" onclick="showNextSection(4)">Continue</div>
</section>

<!-- SECTION 4: Dropout Explanation -->
<section id="section4">
    <p>To solve this, the authors employed a technique called <strong>Dropout</strong> in the fully connected layers. It‚Äôs a concept that sounds counterintuitive: to make the brain work better, we're going to randomly turn off parts of it.</p>
    <div class="continue-button" onclick="showNextSection(5)">Continue</div>
</section>

<!-- SECTION 5: Dropout Interactive -->
<section id="section5">
    <p>During training, for every batch of images, each neuron in the fully connected layers has a probability \(p\) (usually 0.5) of being temporarily 'dropped'‚Äîits output is set to zero.</p>
    <div class="interactive-container">
        <div class="canvas-wrapper">
            <canvas id="dropoutCanvas"></canvas>
        </div>
        <div class="controls">
            <label for="dropoutSlider">Dropout Probability ($p$): <span id="dropoutValue">0.5</span></label>
            <input type="range" id="dropoutSlider" min="0" max="0.9" step="0.01" value="0.5">
            <div class="labels">
                <span>0% (All Active)</span>
                <span>90% (Sparse)</span>
            </div>
        </div>
        <div class="legend">
            <span class="dot active"></span> Active Node
            <span class="dot inactive"></span> Dropped Node
            <span class="line-sample"></span> Data Flow
        </div>
    </div>
    
    <script>
    (function() {
        const canvas = document.getElementById('dropoutCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('dropoutSlider');
        const valueDisplay = document.getElementById('dropoutValue');
        
        // Configuration
        const layers = [3, 6, 6, 2]; // Number of nodes per layer (Input, Hidden1, Hidden2, Output)
        const nodeRadius = 12;
        let nodes = [];
        let pulses = []; // For animation signals
        let dropoutRate = 0.5;
    
        // Helper to get color from CSS variables or hardcoded theme
        const colors = {
            active: '#667eea',
            inactive: '#e2e8f0',
            connection: 'rgba(102, 126, 234, 0.3)',
            pulse: '#764ba2'
        };
    
        class Node {
            constructor(layerIndex, nodeIndex, totalInLayer) {
                this.layerIndex = layerIndex;
                this.nodeIndex = nodeIndex;
                
                // Assign a random threshold for dropout stability
                // If randomVal > dropoutRate, node stays active
                this.randomVal = Math.random(); 
                
                // Input (0) and Output (last) layers never drop out
                this.isProtected = (layerIndex === 0 || layerIndex === layers.length - 1);
                
                this.x = 0;
                this.y = 0;
            }
    
            updatePosition(width, height) {
                const layerSpacing = width / (layers.length);
                const nodeSpacing = height / (layers[this.layerIndex]);
                
                // Centering logic
                const layerWidth = layerSpacing * (layers.length - 1);
                const startX = (width - layerWidth) / 2;
                
                this.x = startX + (this.layerIndex * layerSpacing);
                this.y = (height / 2) - ((layers[this.layerIndex] - 1) * nodeSpacing / 2) + (this.nodeIndex * nodeSpacing);
            }
    
            isActive() {
                if (this.isProtected) return true;
                return this.randomVal >= dropoutRate;
            }
        }
    
        class Pulse {
            constructor(startNode, endNode) {
                this.startNode = startNode;
                this.endNode = endNode;
                this.progress = 0;
                this.speed = 0.05 + Math.random() * 0.02;
                this.alive = true;
            }
    
            update() {
                this.progress += this.speed;
                if (this.progress >= 1) {
                    this.alive = false;
                    // Trigger next layer pulse? (Optional simplification: just spawn random pulses)
                }
            }
    
            draw(ctx) {
                if (!this.startNode.isActive() || !this.endNode.isActive()) return;
                
                const x = this.startNode.x + (this.endNode.x - this.startNode.x) * this.progress;
                const y = this.startNode.y + (this.endNode.y - this.startNode.y) * this.progress;
                
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fillStyle = colors.pulse;
                ctx.fill();
            }
        }
    
        function init() {
            nodes = [];
            layers.forEach((count, lIndex) => {
                let layerNodes = [];
                for (let i = 0; i < count; i++) {
                    layerNodes.push(new Node(lIndex, i, count));
                }
                nodes.push(layerNodes);
            });
            resize();
        }
    
        function resize() {
            // Handle high DPI displays
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.parentNode.getBoundingClientRect();
            
            // Skip if section is not visible (dimensions are 0)
            if (rect.width === 0 || rect.height === 0) {
                return;
            }
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;

            // Recalculate node positions
            nodes.forEach(layer => {
                layer.forEach(node => {
                    node.updatePosition(rect.width, rect.height);
                });
            });
        }
    
        function draw() {
            // Get current dimensions
            const rect = canvas.parentNode.getBoundingClientRect();
            
            // Skip drawing if section is not visible (dimensions are 0)
            if (rect.width === 0 || rect.height === 0) {
                requestAnimationFrame(draw);
                return;
            }
            
            // Clear canvas - use CSS dimensions since context is scaled by DPR
            ctx.clearRect(0, 0, rect.width, rect.height);
    
            // 1. Draw Connections
            for (let l = 0; l < nodes.length - 1; l++) {
                const currentLayer = nodes[l];
                const nextLayer = nodes[l+1];
    
                currentLayer.forEach(n1 => {
                    nextLayer.forEach(n2 => {
                        const active1 = n1.isActive();
                        const active2 = n2.isActive();
    
                        ctx.beginPath();
                        ctx.moveTo(n1.x, n1.y);
                        ctx.lineTo(n2.x, n2.y);
    
                        if (active1 && active2) {
                            ctx.strokeStyle = colors.connection;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        } else {
                            // Faint line for inactive structure visualization
                            ctx.strokeStyle = 'rgba(200, 200, 200, 0.1)';
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    });
                });
            }
    
            // 2. Manage and Draw Pulses (Data Flow Animation)
            // Spawn new pulses
            if (Math.random() < 0.1) {
                // Pick a random layer (except last)
                const lIndex = Math.floor(Math.random() * (nodes.length - 1));
                const startNode = nodes[lIndex][Math.floor(Math.random() * nodes[lIndex].length)];
                const endNode = nodes[lIndex+1][Math.floor(Math.random() * nodes[lIndex+1].length)];
                
                if (startNode.isActive() && endNode.isActive()) {
                    pulses.push(new Pulse(startNode, endNode));
                }
            }
    
            // Update pulses
            for (let i = pulses.length - 1; i >= 0; i--) {
                pulses[i].update();
                if (!pulses[i].alive) {
                    pulses.splice(i, 1);
                } else {
                    pulses[i].draw(ctx);
                }
            }
    
            // 3. Draw Nodes
            nodes.forEach(layer => {
                layer.forEach(node => {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
                    
                    if (node.isActive()) {
                        // Active Gradient
                        const grad = ctx.createLinearGradient(node.x - 10, node.y - 10, node.x + 10, node.y + 10);
                        grad.addColorStop(0, '#667eea');
                        grad.addColorStop(1, '#764ba2');
                        ctx.fillStyle = grad;
                        ctx.shadowColor = 'rgba(118, 75, 162, 0.4)';
                        ctx.shadowBlur = 10;
                    } else {
                        // Inactive Gray
                        ctx.fillStyle = colors.inactive;
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.fill();
                    ctx.shadowBlur = 0; // Reset shadow
                });
            });
    
            requestAnimationFrame(draw);
        }
    
        // Event Listeners
        slider.addEventListener('input', (e) => {
            dropoutRate = parseFloat(e.target.value);
            valueDisplay.textContent = dropoutRate.toFixed(2);
        });
    
        window.addEventListener('resize', resize);
        
        let initialized = false;
        let initTimeout = null;
        
        function doInitialize() {
            if (initialized) return;
            const section = document.getElementById('section5');
            if (section && section.classList.contains('visible')) {
                const rect = canvas.parentNode.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    if (!initialized) {
                        init();
                        initialized = true;
                    }
                    resize();
                    requestAnimationFrame(draw);
                }
            }
        }
        
        // Bootstrap - wait for section to be visible
        function initializeWhenVisible() {
            doInitialize();
            if (!initialized) {
                initTimeout = setTimeout(initializeWhenVisible, 100);
            }
        }
        
        // Try immediate initialization
        doInitialize();
        if (!initialized) {
            initializeWhenVisible();
        }
        
        // Re-initialize when section becomes visible
        const observer = new MutationObserver(() => {
            doInitialize();
        });
        
        const section5 = document.getElementById('section5');
        if (section5) {
            observer.observe(section5, { attributes: true, attributeFilter: ['class'] });
        }
        
    })();
    </script>
    <p>By setting \(p=0.5\), we force the network to sample a different architecture for every training step. This prevents neurons from co-adapting‚Äîbasically, one neuron can't rely solely on a specific neighbor to fix its mistakes, because that neighbor might be turned off.</p>
    <div class="continue-button" onclick="showNextSection(6)">Continue</div>
</section>

<!-- SECTION 6: Dropout Vocab -->
<section id="section6">
    <p>This forces the network to learn robust features that are useful in many different contexts.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Dropout</h4>
        <p>A regularization technique where randomly selected neurons are ignored during training. This simulates training a large ensemble of different neural networks and prevents overfitting.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(7)">Continue</div>
</section>

<!-- SECTION 7: Dropout Test -->
<section id="section7">
    <p>It doubles the training time, but without it, AlexNet would have overfitted almost immediately.</p>
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>What happens to Dropout during the testing phase (when we actually use the model)?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'If we keep it on, the predictions would be random and unstable depending on which neurons are dropped.')">We keep it on to ensure robustness.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! At test time, we want the full power of the network. We multiply the weights by \\(p\\) (or scale the outputs) to account for the fact that more neurons are active than during training.')">We turn it off and use all neurons.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'A probability of 1.0 means dropping 100% of neurons, which would result in zero output.')">We increase the probability to 1.0.</div>
        </div>
    </div>
    <div class="continue-button" onclick="showNextSection(8)">Continue</div>
</section>

<!-- SECTION 8: Recipe Intro -->
<section id="section8">
    <h2>The Training Recipe</h2>
    <p>Building a deep network is like baking a souffl√©; you need the exact right temperature and ingredients, or it collapses. The 'recipe' for AlexNet (the hyperparameters) became a standard for years.</p>
    <div class="continue-button" onclick="showNextSection(9)">Continue</div>
</section>

<!-- SECTION 9: SGD -->
<section id="section9">
    <p>The network was trained using <strong>Stochastic Gradient Descent (SGD)</strong> with these specific settings:</p>
    <div class="continue-button" onclick="showNextSection(10)">Continue</div>
</section>

<!-- SECTION 10: Recipe List -->
<section id="section10">
    <ul>
        <li><strong>Batch Size:</strong> 128 images per step.</li>
        <li><strong>Momentum:</strong> 0.9.</li>
        <li><strong>Weight Decay:</strong> 0.0005.</li>
    </ul>
    <div class="continue-button" onclick="showNextSection(11)">Continue</div>
</section>

<!-- SECTION 11: Weight Decay -->
<section id="section11">
    <p>The <strong>Weight Decay</strong> here is interesting. It acts as L2 Regularization (\(w_{new} = w_{old} - \lambda w_{old}\)), which penalizes large weights. The authors found this wasn't just for preventing overfitting‚Äîit was actually necessary for the training error to go down at all.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Stochastic Gradient Descent (SGD)</h4>
        <p>An iterative method for optimizing an objective function. It estimates the error gradient using a small batch of data rather than the entire dataset.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(12)">Continue</div>
</section>

<!-- SECTION 12: Hardware -->
<section id="section12">
    <p>And then there was the hardware problem. In 2012, the flagship GPU was the NVIDIA GTX 580. It had only 3GB of memory. AlexNet was too big to fit.</p>
    <div class="continue-button" onclick="showNextSection(13)">Continue</div>
</section>

<!-- SECTION 13: GPU Split -->
<section id="section13">
    <p>To fix this, they sliced the network in half. They put half the kernels on GPU 1 and half on GPU 2. The GPUs only talked to each other at specific layers (Layer 3 and the Fully Connected layers).</p>
    <div class="image-placeholder">
        <img src="images/2.jpg" alt="AlexNet architecture split across two GPU streams showing communication between specific layers">
        <p class="image-caption">Divide and conquer: splitting AlexNet across two GPUs to overcome memory constraints.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(14)">Continue</div>
</section>

<!-- SECTION 14: Stop and Think -->
<section id="section14">
    <div class="check-your-knowledge">
        <h3>Stop and Think</h3>
        <h4>AlexNet took 5 to 6 days to train on two GTX 580s. Today, we can train it in minutes. How does this massive speedup change how we do science?</h4>
        <div id="sat-speed-answer" style="display:none;" class="animate-in">
            <strong>Answer:</strong> It dramatically increases the iteration speed. In 2012, if you had a new idea, you waited a week to see if it worked. Today, you can test 50 ideas in a day. This acceleration is a major reason why AI capabilities have exploded.
        </div>
        <button class="reveal-button" onclick="revealAnswer('sat-speed-answer')">Reveal Answer</button>
    </div>
    <div class="continue-button" onclick="showNextSection(15)">Continue</div>
</section>

<!-- SECTION 15: Results Intro -->
<section id="section15">
    <h2>Opening the Black Box: Results</h2>
    <p>After 6 days of training and 90 cycles through the dataset, what did the network actually learn? Was it just memorizing pixels?</p>
    <div class="continue-button" onclick="showNextSection(16)">Continue</div>
</section>

<!-- SECTION 16: Results Visuals -->
<section id="section16">
    <p>The authors visualized the filters (kernels) from the very first convolutional layer. Remember, the network started with random noise. It <em>learned</em> these patterns on its own.</p>
    <div class="image-placeholder">
        <img src="images/3.jpg" alt="Primary visual cortex feature detectors showing 96 learned filters with Gabor edges and color blobs">
        <p class="image-caption">What AlexNet sees: learned feature detectors mirroring biological vision.</p>
    </div>
    <p>Look closely at the visualization above. You see oriented edges (stripes) and color blobs. These are similar to Gabor filters, which scientists used to hand-code. AlexNet discovered that these are the best fundamental building blocks for vision without being told!</p>
    <div class="why-it-matters">
        <h3>Why It Matters</h3>
        <p>This validated the core promise of Deep Learning: Feature Learning. We no longer need to figure out how to describe an edge or a curve mathematically. The network figures it out from the data.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(17)">Continue</div>
</section>

<!-- SECTION 17: Transfer Learning Intro -->
<section id="section17">
    <h2>Recycling the Brain: Transfer Learning</h2>
    <p>This leads us to one of the most powerful concepts in modern AI. If AlexNet learned how to detect edges, textures, and shapes to recognize 1,000 objects, can we use that knowledge for <em>other</em> objects?</p>
    <div class="continue-button" onclick="showNextSection(18)">Continue</div>
</section>

<!-- SECTION 18: Transfer Learning Def -->
<section id="section18">
    <p>Yes! This is called <strong>Transfer Learning</strong>.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Transfer Learning</h4>
        <p>A technique where a model developed for a task is reused as the starting point for a model on a second task. Typically, the pre-trained feature extraction layers are kept, and only the final classification layer is retrained.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(19)">Continue</div>
</section>

<!-- SECTION 19: Shoe Example -->
<section id="section19">
    <p>Imagine you want to build a classifier to distinguish between 300 types of shoes. You don't have 1.2 million images of shoes. You don't need to start from scratch.</p>
    <div class="continue-button" onclick="showNextSection(20)">Continue</div>
</section>

<!-- SECTION 20: Transfer Interactive -->
<section id="section20">
    <p>You can take a pre-trained AlexNet, chop off the final 'head' (the 1000-way output layer), and replace it with a new 300-way output layer.</p>
    <div class="tl-interactive-container">
        <div class="tl-canvas-wrapper">
            <canvas id="transferCanvas"></canvas>
        </div>
        <div class="tl-controls">
            <button id="btnPerformTransfer" class="action-btn">‚úÇÔ∏è Prepare for Transfer Learning</button>
            <button id="btnResetTransfer" class="reset-btn" disabled>‚Ü∫ Reset</button>
        </div>
        <div class="tl-status" id="tlStatusText">Status: Pre-trained AlexNet (1000 Classes)</div>
    </div>
    
    <script>
    (function() {
        const canvas = document.getElementById('transferCanvas');
        const ctx = canvas.getContext('2d');
        const btnAction = document.getElementById('btnPerformTransfer');
        const btnReset = document.getElementById('btnResetTransfer');
        const statusText = document.getElementById('tlStatusText');
    
        let animationId;
        let state = 'IDLE'; // IDLE, ANIMATING, DONE
        let time = 0; // Animation timeline
    
        // Graphics Configuration
        const colors = {
            conv: '#4facfe',
            frozen: '#a0aec0', // Grayed out/Frozen look
            fc: '#667eea',
            oldHead: '#f56565', // Red for old 1000 classes
            newHead: '#48bb78', // Green for new classes
            text: '#2d3748'
        };
    
        // Layout
        let width, height;
        
        // Animation Phases
        // 0-40: Freeze layers
        // 40-100: Scissors enter and cut
        // 100-140: Old head falls
        // 140-200: New head enters
        
        function resize() {
            const rect = canvas.parentNode.getBoundingClientRect();
            
            // Skip if section is not visible (dimensions are 0)
            if (rect.width === 0 || rect.height === 0) {
                return;
            }
            
            const dpr = window.devicePixelRatio || 1;
            width = rect.width;
            height = rect.height;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
        }
    
        function drawRoundedRect(x, y, w, h, r, color, label, subLabel = "") {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            
            // Fill
            const grad = ctx.createLinearGradient(x, y, x, y+h);
            grad.addColorStop(0, color);
            // Darken slightly for bottom
            grad.addColorStop(1, shadeColor(color, -20)); 
            ctx.fillStyle = grad;
            ctx.fill();
    
            // Stroke
            ctx.strokeStyle = 'rgba(0,0,0,0.1)';
            ctx.lineWidth = 1;
            ctx.stroke();
    
            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + w/2, y + h/2 - (subLabel ? 5 : -4));
            
            if (subLabel) {
                ctx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillText(subLabel, x + w/2, y + h/2 + 12);
            }
        }
    
        function drawLock(x, y) {
            ctx.fillStyle = 'white';
            ctx.strokeStyle = '#4a5568';
            ctx.lineWidth = 2;
            
            // Body
            ctx.fillRect(x, y + 6, 12, 10);
            ctx.strokeRect(x, y + 6, 12, 10);
            
            // Shackle
            ctx.beginPath();
            ctx.arc(x + 6, y + 6, 4, Math.PI, 0);
            ctx.stroke();
        }
    
        function drawScissors(x, y, angle) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            
            ctx.fillStyle = '#718096';
            ctx.strokeStyle = '#2d3748';
            ctx.lineWidth = 2;
    
            // Blade 1
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(25, -5);
            ctx.lineTo(0, -5);
            ctx.fill();
            ctx.stroke();
    
            // Blade 2
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(25, 5);
            ctx.lineTo(0, 5);
            ctx.fill();
            ctx.stroke();
    
            // Handle
            ctx.beginPath();
            ctx.arc(-5, -5, 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(-5, 5, 5, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
    
        function render() {
            // Get current dimensions and check if section is visible
            const rect = canvas.parentNode.getBoundingClientRect();
            
            // Skip rendering if section is not visible (dimensions are 0)
            if (rect.width === 0 || rect.height === 0 || !width || !height) {
                if (state === 'ANIMATING') {
                    requestAnimationFrame(render);
                }
                return;
            }
            
            // Ensure canvas is properly sized
            if (width !== rect.width || height !== rect.height) {
                resize();
            }
            
            ctx.clearRect(0, 0, width, height);
            
            const centerY = height / 2;
            const blockH = 60;
            const gap = 40;
            
            // Calculate Positions
            const xConv = width * 0.15;
            const wConv = width * 0.25;
            
            const xFC = xConv + wConv + gap;
            const wFC = width * 0.15;
            
            const xHead = xFC + wFC + gap;
            const wHead = width * 0.15;
    
            // --- Logic based on Time ---
            
            // 1. Convolution Block (Feature Extractor)
            // Freezes (turns gray) between t=0 and t=40
            let convColor = colors.conv;
            if (time > 0) {
                convColor = colors.frozen;
            }
            drawRoundedRect(xConv, centerY - blockH/2, wConv, blockH, 8, convColor, "Conv Layers", "Features");
            
            // Draw Lock if frozen
            if (time > 10) {
                drawLock(xConv + wConv/2 - 6, centerY - blockH/2 - 20);
                ctx.fillStyle = '#718096';
                ctx.font = 'bold 12px sans-serif';
                ctx.fillText("FROZEN", xConv + wConv/2, centerY - blockH/2 - 25);
            }
    
            // Arrow 1
            drawArrow(xConv + wConv, centerY, xFC, centerY);
    
            // 2. FC Block
            drawRoundedRect(xFC, centerY - blockH/2, wFC, blockH, 8, colors.fc, "Dense", "4096 units");
    
            // 3. Old Head (1000 Classes)
            // Falls away between t=100 and t=140
            let oldHeadY = centerY - blockH/2;
            let oldHeadAlpha = 1;
            
            if (time > 100) {
                const dropProgress = Math.min(1, (time - 100) / 40);
                oldHeadY += dropProgress * dropProgress * 150; // Gravity accel
                oldHeadAlpha = 1 - dropProgress;
            }
    
            if (oldHeadAlpha > 0) {
                ctx.globalAlpha = oldHeadAlpha;
                drawRoundedRect(xHead, oldHeadY, wHead, blockH, 8, colors.oldHead, "Softmax", "1000 Classes");
                
                // Connection to Old Head
                if (time < 90) { // Cut happens around 90
                    ctx.globalAlpha = 1;
                    drawArrow(xFC + wFC, centerY, xHead, centerY);
                }
                ctx.globalAlpha = 1;
            }
    
            // 4. Scissors Animation (t=40 to t=100)
            if (time > 40 && time < 110) {
                const scissorProgress = (time - 40) / 60; // 0 to 1
                // Move scissors to the connection point
                const cutX = xFC + wFC + gap/2;
                const cutY = centerY;
                
                // Enter from top
                let sX = cutX;
                let sY = cutY;
                let angle = 0;
    
                if (scissorProgress < 0.5) {
                    // Moving down
                    sY = cutY - 50 + (scissorProgress * 2 * 50);
                    angle = Math.PI / 4; // Open
                } else {
                    // Cutting action
                    sY = cutY;
                    const snip = (scissorProgress - 0.5) * 2; // 0 to 1
                    // Snip: Open -> Closed -> Open
                    if (snip < 0.5) angle = (1 - snip*2) * (Math.PI/4); 
                    else angle = (snip-0.5) * (Math.PI/4);
                }
    
                drawScissors(sX, sY, angle);
            }
    
            // 5. New Head (3 Classes)
            // Enters from top between t=140 and t=180
            if (time > 140) {
                const entryProgress = Math.min(1, (time - 140) / 40);
                // Ease Out Back animation
                const c1 = 1.70158;
                const c3 = c1 + 1;
                const ease = 1 + c3 * Math.pow(entryProgress - 1, 3) + c1 * Math.pow(entryProgress - 1, 2);
                
                const startY = -60;
                const endY = centerY - blockH/2;
                const currentY = startY + (endY - startY) * ease;
    
                drawRoundedRect(xHead, currentY, wHead, blockH, 8, colors.newHead, "New Head", "3 Classes");
                
                // New Connection
                if (entryProgress >= 0.9) {
                    drawArrow(xFC + wFC, centerY, xHead, centerY, true); // True = highlight
                }
            }
    
            if (state === 'ANIMATING') {
                time += 2;
                if (time > 200) {
                    state = 'DONE';
                    statusText.innerHTML = "Status: <strong>Ready to Fine-Tune!</strong>";
                    btnAction.disabled = true;
                    btnReset.disabled = false;
                } else {
                    // Update Status Text based on phase
                    if (time < 40) statusText.innerText = "Status: Freezing feature extraction layers...";
                    else if (time < 100) statusText.innerText = "Status: Removing original classifier...";
                    else if (time < 140) statusText.innerText = "Status: Discarding old weights...";
                    else statusText.innerText = "Status: Attaching new initialized layer...";
                    
                    requestAnimationFrame(render);
                }
            } else {
                // Static render if needed (e.g. after resize)
            }
        }
    
        function drawArrow(x1, y1, x2, y2, highlight = false) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2 - 5, y2);
            ctx.strokeStyle = highlight ? '#48bb78' : '#cbd5e1';
            ctx.lineWidth = highlight ? 3 : 2;
            ctx.stroke();
    
            // Arrowhead
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - 8, y2 - 4);
            ctx.lineTo(x2 - 8, y2 + 4);
            ctx.fillStyle = highlight ? '#48bb78' : '#cbd5e1';
            ctx.fill();
        }
    
        // Color helper
        function shadeColor(color, percent) {
            var R = parseInt(color.substring(1,3),16);
            var G = parseInt(color.substring(3,5),16);
            var B = parseInt(color.substring(5,7),16);
    
            R = parseInt(R * (100 + percent) / 100);
            G = parseInt(G * (100 + percent) / 100);
            B = parseInt(B * (100 + percent) / 100);
    
            R = (R<255)?R:255;  
            G = (G<255)?G:255;  
            B = (B<255)?B:255;  
    
            var RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            var GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            var BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
    
            return "#"+RR+GG+BB;
        }
    
        // Interaction
        btnAction.addEventListener('click', () => {
            if (state !== 'IDLE') return;
            // Ensure canvas is initialized
            doInitialize();
            if (!initialized) return;
            state = 'ANIMATING';
            btnAction.disabled = true;
            render();
        });
        
        btnReset.addEventListener('click', () => {
            // Ensure canvas is initialized
            doInitialize();
            if (!initialized) return;
            state = 'IDLE';
            time = 0;
            statusText.innerText = "Status: Pre-trained AlexNet (1000 Classes)";
            btnAction.disabled = false;
            btnReset.disabled = true;
            render();
        });
    
        window.addEventListener('resize', () => {
            resize();
            render();
        });
        
        let initialized = false;
        let initTimeout = null;
        
        function doInitialize() {
            const section = document.getElementById('section20');
            if (section && section.classList.contains('visible')) {
                const rect = canvas.parentNode.getBoundingClientRect();
                if (rect.width > 0 && rect.height > 0) {
                    if (!initialized) {
                        resize();
                        initialized = true;
                    } else {
                        // Re-resize if dimensions changed
                        resize();
                    }
                    // Trigger render
                    render();
                }
            }
        }
        
        // Bootstrap - wait for section to be visible
        function initializeWhenVisible() {
            doInitialize();
            if (!initialized) {
                initTimeout = setTimeout(initializeWhenVisible, 100);
            }
        }
        
        // Try immediate initialization
        doInitialize();
        if (!initialized) {
            initializeWhenVisible();
        }
        
        // Re-initialize when section becomes visible
        const observer = new MutationObserver(() => {
            doInitialize();
        });
        
        const section20 = document.getElementById('section20');
        if (section20) {
            observer.observe(section20, { attributes: true, attributeFilter: ['class'] });
        }
        
    })();
    </script>
    <div class="continue-button" onclick="showNextSection(21)">Continue</div>
</section>

<!-- SECTION 21: Check Understanding Transfer -->
<section id="section21">
    <div class="test-your-knowledge">
        <h3>Check Your Understanding</h3>
        <h4>If we use Transfer Learning, do we need to retrain the Convolutional layers (the early layers) from scratch?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Retraining them from scratch defeats the purpose. The early layers already know how to see edges and shapes, which are useful for ALL images.')">Yes, because the new images are different.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Exactly! The convolutional layers act as a generic feature extractor. We mostly just need to train the new final layer to interpret those features for the new classes.')">No, we can 'freeze' them or just slightly fine-tune them.</div>
        </div>
    </div>
    <div class="continue-button" onclick="showNextSection(22)">Continue</div>
</section>

<!-- SECTION 22: Industry Usage -->
<section id="section22">
    <p>This ability to reuse weights is how 90% of industry practitioners use AI today. You rarely train a massive model from scratch; you stand on the shoulders of giants like AlexNet.</p>
    <div class="continue-button" onclick="showNextSection(23)">Continue</div>
</section>

<!-- SECTION 23: Review -->
<section id="section23">
    <h2>Review and Reflect</h2>
    <p>We have now completed our deep dive into the AlexNet revolution.</p>
    <p>In this lesson, we explored the engineering reality of training deep networks:</p>
    <ul>
        <li><strong>Dropout</strong> prevents the network from memorizing data by randomly disabling neurons during training.</li>
        <li><strong>Training Recipes</strong> involving specific momentum and weight decay are crucial for convergence.</li>
        <li><strong>Multi-GPU</strong> setups were born out of necessity but paved the way for massive parallel computing.</li>
        <li><strong>Transfer Learning</strong> allows us to reuse the visual features learned by these massive networks for our own smaller tasks.</li>
    </ul>
    <p>AlexNet didn't just win a competition; it provided the blueprint‚Äîarchitecture + ReLU + Dropout + GPUs‚Äîthat every subsequent computer vision breakthrough has followed.</p>
    
    <div class="frequently-asked">
        <h3>Frequently Asked Questions</h3>
        <h4>Is the Two-GPU split still used today?</h4>
        <p>Not in the way AlexNet did it. Modern GPUs have much more memory (24GB, 40GB, 80GB+), so we can fit entire models on one card. However, for massive Large Language Models (LLMs) like GPT, we still split models across hundreds of GPUs, but using more advanced parallelism techniques.</p>
    </div>

    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>Which of the following best describes the role of Weight Decay in AlexNet?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'No, that represents a learning rate schedule.')">It increases the learning rate over time.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'That is Dropout.')">It randomly sets weights to zero.</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct. By adding a small penalty to the loss function proportional to the size of the weights, it prevents the model from relying too heavily on any single connection.')">It penalizes large weights to regularize the model and help it learn.</div>
        </div>
    </div>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">‚úì Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 23;

updateProgress();
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event && event.target;
    if (!nextSectionElement) return;
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    setTimeout(() => { nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // Default placeholders, to be determined by the specific course context
                let courseId = 'computer-vision';
                let pathId = 'deep-learning-foundations';
                let moduleId = 'alexnet';
                let lessonId = 'training-the-beast';
                
                if (window.parent.currentRoute) {
                    const route = window.parent.currentRoute;
                    if (route.courseId) courseId = route.courseId;
                    if (route.pathId) pathId = route.pathId;
                    if (route.moduleId) moduleId = route.moduleId;
                    if (route.lessonId) lessonId = route.lessonId;
                }
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('course')) courseId = urlParams.get('course');
                if (urlParams.get('path')) pathId = urlParams.get('path');
                if (urlParams.get('module')) moduleId = urlParams.get('module');
                if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = '‚úÖ Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv-alexnet-training_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['üéâ', 'üéä', '‚ú®', 'üåü', 'üéà', 'üèÜ', 'üëè', 'ü•≥'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = '‚óè';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = 'üéâ Lesson Completed! Great Job! üéâ';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    // Check local storage or parent
    const isCompleted = localStorage.getItem('lesson_cv-alexnet-training_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = '‚úÖ Completed!';
    }
});
</script>
</body>
</html>