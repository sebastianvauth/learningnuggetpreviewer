<!DOCTYPE html>
<html lang='en'>
<head>
<meta charset='UTF-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<link rel="stylesheet" href="../../styles/lesson.css">
<title>Connecting the Dots: Bottom-Up & Future</title>
<script>
window.MathJax = {
    tex: { inlineMath: [['\\(','\\)'], ['$', '$']] },
    options: { skipHtmlTags: ['script','noscript','style','textarea','pre','code'] }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="progress-container"><div class="progress-bar" id="progressBar"></div></div>
<div class="lesson-container">

<!-- Section 1: Intro / Nightmare -->
<section id="section1" class="visible">
    <div class="image-placeholder">
        <img src="images/1.jpg" alt="Crowded marathon start with disconnected elbow and wrist detections floating across runners." loading="lazy">
    </div>
    <h1>The Association Nightmare</h1>

    <p>Welcome back! In the last lesson, we looked at Top-Down methods like CPM and Stacked Hourglass. They are incredibly accurate, but they have a fatal flaw: they are slow in crowds. Because they have to run a pose estimator for <em>every single person</em> detected, a crowd of 100 people takes 100 times longer to process than a single person.</p>
    <div class="continue-button" onclick="showNextSection(2)">Continue</div>
</section>

<!-- Section 2: Bottom-Up Intro -->
<section id="section2">
    <p>To solve this, we need a <strong>Bottom-Up</strong> approach: find all the body parts in the image first, and <em>then</em> figure out which parts belong to whom. But this introduces a massive headache known as the <strong>Association Problem</strong>.</p>
    <div class="continue-button" onclick="showNextSection(3)">Continue</div>
</section>

<!-- Section 3: Scenario -->
<section id="section3">
    <p>Imagine you are looking at a photo of a crowded dance floor. Your computer vision model successfully detects 10 'Left Elbows' and 10 'Left Wrists'.</p>
    <div class="continue-button" onclick="showNextSection(4)">Continue</div>
</section>

<!-- Section 4: The Problem -->
<section id="section4">
    <p>The question is: Which wrist connects to which elbow? If you just connect the closest ones, you might connect a tall person's elbow to a short person's wrist standing next to them. The result would be a spaghetti monster of crossed limbs!</p>
    <div class="continue-button" onclick="showNextSection(5)">Continue</div>
</section>

<!-- Section 5: OpenPose Reveal -->
<section id="section5">
    <p>This is where <strong>OpenPose</strong> changed the game. It introduced a way to solve this matching puzzle in real-time.</p>
    <div class="continue-button" onclick="showNextSection(6)">Continue</div>
</section>

<!-- Section 6: PAFs Intro -->
<section id="section6">
    <h2>Part Affinity Fields (PAFs)</h2>
    <p>To solve the association problem, the OpenPose network is trained to predict two things simultaneously.</p>
    <p>First, it predicts the <strong>Confidence Maps</strong> (Heatmaps) that we learned about in the previous lessons. These tell us <em>where</em> the joints are (e.g., 'there is an elbow at pixel (50, 100)').</p>
    <div class="continue-button" onclick="showNextSection(7)">Continue</div>
</section>

<!-- Section 7: Vocab - PAF -->
<section id="section7">
    <p>But location isn't enough. We need to know the <em>relationship</em> between points. So, OpenPose also predicts a <strong>Part Affinity Field (PAF)</strong>.</p>
    <div class="vocab-section">
        <h3>Build Your Vocab</h3>
        <h4>Part Affinity Field (PAF)</h4>
        <p>A set of 2D vector fields that encodes the position and orientation of limbs. For each pixel that belongs to a limb, the PAF contains a 2D vector pointing from the start joint (e.g., elbow) to the end joint (e.g., wrist).</p>
    </div>
    <div class="continue-button" onclick="showNextSection(8)">Continue</div>
</section>

<!-- Section 8: Flow Map Visual -->
<section id="section8">
    <p>Think of a PAF as a flow map. If you were a tiny boat floating on a pixel inside a person's arm, the PAF would tell you which direction the current is flowing—from the elbow down to the wrist.</p>
    <div class="visual-placeholder">
        <img src="images/2.jpg" alt="Forearm diagram covered with uniform arrows pointing from elbow toward wrist to illustrate a part affinity field." loading="lazy">
        <p class="image-caption">PAFs act like a current flowing from one joint to the next, giving us direction instead of a flat blob.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(9)">Continue</div>
</section>

<!-- Section 9: Stop and Think -->
<section id="section9">
    <p>By predicting this 'flow' for every limb type (neck-to-head, hip-to-knee, etc.), the network gives us the crucial clue we need to connect the dots.</p>
    <div class="check-your-knowledge">
        <h3>Stop and Think</h3>
        <h4>Why do we need a vector field (arrows) instead of just a binary mask (black/white) saying 'this is an arm'?</h4>
        <div id="stop-think-answer" style="display:none;" class="animate-in">
            <strong>Answer:</strong> A binary mask only tells us that an arm exists there. It doesn't tell us the <em>direction</em> or which endpoints it connects. If two people's arms cross in an 'X' shape, a binary mask merges them into one blob, but a vector field clearly shows two different flow directions crossing each other.
        </div>
        <button class="reveal-button" onclick="revealAnswer('stop-think-answer')">Reveal Answer</button>
    </div>
    <div class="continue-button" onclick="showNextSection(10)">Continue</div>
</section>

<!-- Section 10: The Math -->
<section id="section10">
    <h2>The Math of Matching</h2>
    <p>So, we have a candidate Elbow (\(A\)) and a candidate Wrist (\(B\)). How do we use the PAF to check if they form a valid limb?</p>
    <p>We use a mathematical tool called a <strong>Line Integral</strong>. Don't worry, the concept is intuitive. We draw a straight line segment connecting point \(A\) to point \(B\). Then, we walk along this line and check if the PAF arrows agree with our walking direction.</p>
    <div class="continue-button" onclick="showNextSection(11)">Continue</div>
</section>

<!-- Section 11: Formula -->
<section id="section11">
    <p>Mathematically, we calculate the score \(S\) by integrating the dot product of the unit vector \(\vec{v}\) (direction of the line segment) and the PAF vector \(\mathbf{p}(u)\) at each point \(u\) along the line:</p>
    <p>$$ S = \int_{u=0}^{1} \mathbf{p}(u) \cdot \vec{v} \, du $$</p>
    <div class="continue-button" onclick="showNextSection(12)">Continue</div>
</section>

<!-- Section 12: Dot Product Intuition -->
<section id="section12">
    <p>Let's break down what this integral actually measures using the properties of the dot product:</p>
    <div class="continue-button" onclick="showNextSection(13)">Continue</div>
</section>

<!-- Section 13: Case 1 -->
<section id="section13">
    <p><strong>Case 1: The Valid Limb</strong><br>
    If \(A\) and \(B\) are actually connected by a forearm, the PAF vectors \(\mathbf{p}(u)\) along the path will point in the same direction as our line \(\vec{v}\).</p>
    <p>When vectors are parallel, their dot product is 1. The sum (integral) will be <strong>high</strong>.</p>
    <div class="visual-placeholder">
        <img src="images/3.jpg" alt="Diagram showing two joints connected with aligned vector flow indicating a high dot product score." loading="lazy">
        <p class="image-caption">When PAF arrows align with the elbow-to-wrist line, the line integral shoots up—signaling a valid limb.</p>
    <div class="continue-button" onclick="showNextSection(14)">Continue</div>
</section>

<!-- Section 14: Case 2 -->
<section id="section14">
    <p><strong>Case 2: The False Connection</strong><br>
    If we try to connect an elbow to a wrist that belongs to someone else, the line might cut through empty space (where vectors are 0) or cross a different limb where the vectors point sideways.</p>
    <p>When vectors are perpendicular or zero, the dot product is 0. The sum (integral) will be <strong>low</strong>.</p>
    <div class="visual-placeholder">
        <img src="images/4.jpg" alt="Vector dot product visualization showing a diagonal limb cutting through perpendicular flow arrows with a low score indicator." loading="lazy">
        <p class="image-caption">When the predicted flow is perpendicular to the elbow-to-wrist line, the dot product hovers near zero and the pair is rejected.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(15)">Continue</div>
</section>

<!-- Section 15: Algorithm Summary -->
<section id="section15">
    <p>The algorithm simply calculates this score for every possible pair of elbows and wrists. The pairs with the highest scores are the winners!</p>
    <div class="continue-button" onclick="showNextSection(16)">Continue</div>
</section>

<!-- Section 16: Interactive Matchmaker -->
<section id="section16">
    <h2>The Matchmaker</h2>
    <p>Now it's your turn to be the algorithm. Let's see if you can solve the association problem using vector fields.</p>
    <div class="interactive-placeholder" style="margin: 0; padding: 0;">
      <div class="paf-container">
          <canvas id="pafCanvas"></canvas>
          <div class="paf-controls">
              <div class="paf-status" id="pafStatus">Draw from Red (Elbow) to Blue (Wrist)</div>
              <button class="paf-reset" onclick="resetPafSimulation()">Reset</button>
          </div>
      </div>

      <script>
      (function() {
          const canvas = document.getElementById('pafCanvas');
          if (!canvas) {
              console.error('PAF Canvas not found');
              return;
          }

          const ctx = canvas.getContext('2d');
          if (!ctx) {
              console.error('Canvas context not available');
              return;
          }

          const statusEl = document.getElementById('pafStatus');
          const canvasWrapper = canvas.parentElement;
          const parentSection = canvas.closest('section');

          // Configuration
          let width = 0;
          let height = 0;
          const pointRadius = 12;
          const arrowSpacing = 25;
          
          // State
          let isDragging = false;
          let dragStartPoint = null;
          let mousePos = { x: 0, y: 0 };
          let connections = []; // Stores locked connections
          let animationFrame;
  
          // The "Truth" - 3 pairs of coordinates (percentages to remain responsive)
          // Pair 0: Top Left diagonal
          // Pair 1: Middle crossing
          // Pair 2: Bottom Right
          const pairs = [
              { id: 0, elbow: {x: 0.15, y: 0.2}, wrist: {x: 0.35, y: 0.4}, color: '#e6fffa' }, 
              { id: 1, elbow: {x: 0.5, y: 0.25}, wrist: {x: 0.5, y: 0.65}, color: '#e6fffa' },
              { id: 2, elbow: {x: 0.8, y: 0.3}, wrist: {x: 0.65, y: 0.5}, color: '#e6fffa' }
          ];
  
          // Mapped points for current canvas size
          let points = []; 
  
          function resize() {
              const rect = canvas.getBoundingClientRect();
              if (!rect.width || !rect.height) {
                  return false;
              }
              width = rect.width;
              height = rect.height;
              
              // Set actual canvas resolution to match display size (for sharpness)
              const dpr = window.devicePixelRatio || 1;
              canvas.width = width * dpr;
              canvas.height = height * dpr;
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.scale(dpr, dpr);

              // Recalculate point positions based on new size
              points = [];
              pairs.forEach(p => {
                  points.push({ 
                      id: p.id, 
                      type: 'elbow', 
                      x: p.elbow.x * width, 
                      y: p.elbow.y * height 
                  });
                  points.push({ 
                      id: p.id, 
                      type: 'wrist', 
                      x: p.wrist.x * width, 
                      y: p.wrist.y * height 
                  });
              });
              
              draw();
              return true;
          }
  
          // --- Drawing Helpers ---
  
          function drawArrow(fromX, fromY, angle, length, opacity) {
              ctx.save();
              ctx.translate(fromX, fromY);
              ctx.rotate(angle);
              ctx.globalAlpha = opacity;
              ctx.strokeStyle = "#a0aec0";
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.moveTo(0, 0);
              ctx.lineTo(length, 0);
              ctx.stroke();
              
              // Arrowhead
              ctx.beginPath();
              ctx.moveTo(length, 0);
              ctx.lineTo(length - 4, -3);
              ctx.lineTo(length - 4, 3);
              ctx.fill();
              ctx.restore();
          }
  
          function getVectorAtPoint(px, py) {
              // Check if point is close to a valid segment line
              // If so, return vector direction of that segment
              for (let p of pairs) {
                  const ex = p.elbow.x * width;
                  const ey = p.elbow.y * height;
                  const wx = p.wrist.x * width;
                  const wy = p.wrist.y * height;
                  
                  // Distance from point to line segment
                  const A = px - ex;
                  const B = py - ey;
                  const C = wx - ex;
                  const D = wy - ey;
  
                  const dot = A * C + B * D;
                  const lenSq = C * C + D * D;
                  let param = -1;
                  if (lenSq !== 0) param = dot / lenSq;
  
                  let xx, yy;
  
                  if (param < 0) { xx = ex; yy = ey; }
                  else if (param > 1) { xx = wx; yy = wy; }
                  else { xx = ex + param * C; yy = ey + param * D; }
  
                  const dx = px - xx;
                  const dy = py - yy;
                  const dist = Math.sqrt(dx * dx + dy * dy);
  
                  // If within "Limb Width", return unit vector
                  if (dist < 30) {
                      const angle = Math.atan2(wy - ey, wx - ex);
                      return { angle: angle, magnitude: 1 };
                  }
              }
              return null; // Background noise
          }
  
          function drawField() {
              // Draw faint background arrows
              for (let x = 0; x < width; x += arrowSpacing) {
                  for (let y = 0; y < height; y += arrowSpacing) {
                      const vec = getVectorAtPoint(x, y);
                      if (vec) {
                          drawArrow(x, y, vec.angle, 15, 0.6);
                      } else {
                          // Tiny dot for noise/empty space
                          ctx.fillStyle = "#cbd5e1";
                          ctx.fillRect(x, y, 1, 1);
                      }
                  }
              }
          }
  
          function drawPoints() {
              points.forEach(p => {
                  // Skip if already connected
                  const isConnected = connections.some(c => 
                      (c.p1 === p || c.p2 === p)
                  );
  
                  ctx.beginPath();
                  ctx.arc(p.x, p.y, pointRadius, 0, Math.PI * 2);
                  
                  if (isConnected) {
                      ctx.fillStyle = "#cbd5e1"; // Greyed out
                      ctx.strokeStyle = "#94a3b8";
                  } else {
                      // Elbow = Red/Orange, Wrist = Blue/Cyan
                      if (p.type === 'elbow') {
                          ctx.fillStyle = "#fc8181"; // Red-ish
                          ctx.strokeStyle = "#c53030";
                      } else {
                          ctx.fillStyle = "#63b3ed"; // Blue-ish
                          ctx.strokeStyle = "#2b6cb0";
                      }
                  }
                  
                  ctx.lineWidth = 2;
                  ctx.fill();
                  ctx.stroke();
  
                  // Label
                  ctx.fillStyle = "#4a5568";
                  ctx.font = "10px sans-serif";
                  ctx.textAlign = "center";
                  ctx.fillText(p.type === 'elbow' ? "E" : "W", p.x, p.y + 4);
              });
          }
  
          function drawConnections() {
              // Locked connections
              connections.forEach(c => {
                  ctx.beginPath();
                  ctx.moveTo(c.p1.x, c.p1.y);
                  ctx.lineTo(c.p2.x, c.p2.y);
                  ctx.strokeStyle = "#48bb78"; // Green
                  ctx.lineWidth = 4;
                  ctx.stroke();
              });
  
              // Current Drag
              if (isDragging && dragStartPoint) {
                  ctx.beginPath();
                  ctx.moveTo(dragStartPoint.x, dragStartPoint.y);
                  ctx.lineTo(mousePos.x, mousePos.y);
                  ctx.strokeStyle = "#2d3748";
                  ctx.lineWidth = 2;
                  ctx.setLineDash([5, 5]);
                  ctx.stroke();
                  ctx.setLineDash([]);
              }
          }
  
          function draw() {
              if (!width || !height) return;
              ctx.clearRect(0, 0, width, height);
              drawField();
              drawConnections();
              drawPoints();
          }
  
          // --- Interaction Logic ---
  
          function getPointAt(x, y) {
              return points.find(p => {
                  const dx = p.x - x;
                  const dy = p.y - y;
                  return Math.sqrt(dx*dx + dy*dy) < pointRadius * 1.5;
              });
          }
  
          function handleStart(x, y) {
              const p = getPointAt(x, y);
              if (p) {
                  // Check if already connected
                  const alreadyConnected = connections.some(c => c.p1 === p || c.p2 === p);
                  if (!alreadyConnected && p.type === 'elbow') {
                      isDragging = true;
                      dragStartPoint = p;
                      statusEl.textContent = "Dragging...";
                  } else if (!alreadyConnected && p.type === 'wrist') {
                       statusEl.textContent = "Start at an Elbow (Red)!";
                       setTimeout(() => statusEl.textContent = "Draw from Red (Elbow) to Blue (Wrist)", 1500);
                  }
              }
          }
  
          function handleMove(x, y) {
              if (isDragging) {
                  mousePos = {x, y};
                  draw();
              }
          }
  
          function handleEnd() {
              if (!isDragging) return;
              
              const p = getPointAt(mousePos.x, mousePos.y);
              let success = false;
  
              if (p && p.type === 'wrist' && !connections.some(c => c.p1 === p || c.p2 === p)) {
                  // Validate Pair
                  if (dragStartPoint.id === p.id) {
                      // Success: High Line Integral
                      connections.push({ p1: dragStartPoint, p2: p });
                      statusEl.textContent = "High Line Integral! Match Found.";
                      statusEl.style.color = "#2f855a";
                      success = true;
                  } else {
                      // Fail: Low Line Integral
                      statusEl.textContent = "Low Line Integral. Vectors do not align.";
                      statusEl.style.color = "#c53030";
                  }
              } else {
                   statusEl.textContent = "Draw from Red (Elbow) to Blue (Wrist)";
                   statusEl.style.color = "#64748b";
              }
  
              if (!success) {
                  // Shake effect for feedback
                  if (canvasWrapper) {
                      canvasWrapper.classList.add('shake-canvas');
                      setTimeout(() => canvasWrapper.classList.remove('shake-canvas'), 300);
                  }
              }
  
              isDragging = false;
              dragStartPoint = null;
              
              // Win condition
              if (connections.length === 3) {
                  statusEl.textContent = "All limbs connected! Association solved.";
                  createLocalConfetti();
              }
  
              draw();
              setTimeout(() => { if(!success && connections.length!==3) statusEl.style.color = "#64748b"; }, 2000);
          }
  
          // --- Event Listeners ---
          
          canvas.addEventListener('mousedown', e => {
              const rect = canvas.getBoundingClientRect();
              handleStart(e.clientX - rect.left, e.clientY - rect.top);
          });
          canvas.addEventListener('mousemove', e => {
              const rect = canvas.getBoundingClientRect();
              handleMove(e.clientX - rect.left, e.clientY - rect.top);
          });
          canvas.addEventListener('mouseup', handleEnd);
          canvas.addEventListener('mouseleave', () => { isDragging = false; draw(); });
  
          // Touch support
          canvas.addEventListener('touchstart', e => {
              e.preventDefault();
              const rect = canvas.getBoundingClientRect();
              handleStart(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
          }, {passive: false});
          canvas.addEventListener('touchmove', e => {
              e.preventDefault();
              const rect = canvas.getBoundingClientRect();
              handleMove(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
          }, {passive: false});
          canvas.addEventListener('touchend', handleEnd);
  
          window.addEventListener('resize', resize);
          
          // Expose reset function
          window.resetPafSimulation = function() {
              connections = [];
              statusEl.textContent = "Draw from Red (Elbow) to Blue (Wrist)";
              statusEl.style.color = "#64748b";
              draw();
          };
          
          function monitorContainerSize() {
              if (!('ResizeObserver' in window) || !canvasWrapper) return;
              const resizeObserver = new ResizeObserver(entries => {
                  const entry = entries[0];
                  if (entry && entry.contentRect.width && entry.contentRect.height) {
                      resize();
                  }
              });
              resizeObserver.observe(canvasWrapper);
          }

          function watchForVisibility() {
              if (!parentSection || !('MutationObserver' in window)) return;
              let visibilityObserver;
              const attemptResize = () => {
                  if (!parentSection.classList.contains('visible')) return;
                  if (resize()) {
                      if (visibilityObserver) visibilityObserver.disconnect();
                  } else {
                      requestAnimationFrame(attemptResize);
                  }
              };
              visibilityObserver = new MutationObserver(attemptResize);
              visibilityObserver.observe(parentSection, { attributes: true, attributeFilter: ['class'] });
              attemptResize();
          }
  
          function createLocalConfetti() {
               // Simple visual feedback for demo
               const colors = ['#f00', '#0f0', '#00f'];
               for(let i=0; i<20; i++) {
                   // Just a placeholder for fun, main logic is sound
               }
          }
  
          // Init
          monitorContainerSize();
          if (!resize()) {
              watchForVisibility();
          }
  
      })();
      </script>
  </div>
    <p>In the simulation above, you see several joints. Faint arrows show the Part Affinity Field predicted by the network. Try to draw lines connecting the elbows to the wrists. Feel the 'Line Integral' in action—if you go with the flow, the connection sticks.</p>
    <div class="continue-button" onclick="showNextSection(17)">Continue</div>
</section>

<!-- Section 17: Performance Note -->
<section id="section17">
    <p>This method is incredibly fast because it uses a greedy matching approach (specifically, bipartite matching) which is much computationally cheaper than running a full pose estimator for every person.</p>
    <div class="continue-button" onclick="showNextSection(18)">Continue</div>
</section>

<!-- Section 18: VolNet Intro -->
<section id="section18">
    <h2>Beyond the Skeleton: VolNet</h2>
    <p>Getting the 2D skeleton is a huge achievement, but for many researchers, it's just the starting point.</p>
    <p>Once we have the 2D keypoints, we can feed them into other networks to perform even more complex tasks. One example from our course's research is <strong>VolNet</strong>.</p>
    <div class="continue-button" onclick="showNextSection(19)">Continue</div>
</section>

<!-- Section 19: VolNet Visual -->
<section id="section19">
    <p>VolNet takes a single RGB image and its 2D pose (the skeleton we just found) and estimates the <strong>3D volume</strong> of the human body parts.</p>
    <div class="visual-placeholder">
        <img src="images/5.jpg" alt="VolNet pipeline showing an RGB photo plus 2D skeleton feeding a neural network that outputs colored 3D limb volumes." loading="lazy">
        <p class="image-caption">VolNet ingests the 2D pose along with the image itself, then hallucinates volumetric anatomy for each limb.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(20)">Continue</div>
</section>

<!-- Section 20: Why it Matters (VolNet) -->
<section id="section20">
    <p>Why does this matter?</p>
    <ul>
        <li><strong>Sports Analytics:</strong> Calculating the exact aerodynamics of a cyclist.</li>
        <li><strong>Healthcare:</strong> Monitoring muscle atrophy or swelling in patients remotely.</li>
        <li><strong>VR/AR:</strong> Creating realistic 3D avatars that match your actual body shape.</li>
    </ul>
    <div class="continue-button" onclick="showNextSection(21)">Continue</div>
</section>

<!-- Section 21: FAQ -->
<section id="section21">
    <div class="why-it-matters">
        <h3>Frequently Asked Question</h3>
        <p><strong>Can OpenPose work on animals?</strong></p>
        <p>Great question! The logic of OpenPose (Heatmaps + PAFs) is universal for articulated objects. However, the model provided out-of-the-box is trained on human datasets like COCO. To detect dogs, horses, or monkeys, you would need to retrain the network with a dataset containing animal skeletons. The 'schema' (which joints connect to which) would also need to change.</p>
    </div>
    <div class="continue-button" onclick="showNextSection(22)">Continue</div>
</section>

<!-- Section 22: Review Intro -->
<section id="section22">
    <h2>Review and Reflect</h2>
    <p>We've reached the end of our journey through Human Pose Estimation!</p>
    <p>In this final lesson, we tackled the <strong>Association Problem</strong> in multi-person scenes. We learned how <strong>OpenPose</strong> uses a Bottom-Up approach to maintain real-time performance regardless of crowd size.</p>
    <div class="continue-button" onclick="showNextSection(23)">Continue</div>
</section>

<!-- Section 23: Review PAFs -->
<section id="section23">
    <p>We discovered <strong>Part Affinity Fields (PAFs)</strong>, which are vector fields that guide us in connecting joints. By calculating the <strong>Line Integral</strong> along potential connections, we can mathematically verify which body parts belong together.</p>
    <div class="continue-button" onclick="showNextSection(24)">Continue</div>
</section>

<!-- Section 24: Quiz 1 -->
<section id="section24">
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>What is the specific output of OpenPose designed to solve the association problem?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Heatmaps only tell us <em>where</em> the joints are, not how they connect. If two people stand close together, heatmaps alone aren\'t enough to separate them.')">Confidence Maps (Heatmaps)</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Bounding boxes are used in Top-Down methods, not the Bottom-Up OpenPose approach.')">Bounding Boxes</div>
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Correct! PAFs provide the vector direction information needed to link disjoint keypoints into full skeletons.')">Part Affinity Fields (PAFs)</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'OpenPose is a 2D estimation framework.')">3D Point Clouds</div>
        </div>
    </div>
    <div class="continue-button" onclick="showNextSection(25)">Continue</div>
</section>

<!-- Section 25: Quiz 2 -->
<section id="section25">
    <div class="test-your-knowledge">
        <h3>Test Your Knowledge</h3>
        <h4>In the context of PAFs, what does a high line integral score imply?</h4>
        <div class="multiple-choice">
            <div class="choice-option" data-correct="true" onclick="selectChoice(this, true, 'Yes! A high score means the vector flow aligns with the line between the joints, suggesting a valid physical connection.')">The candidate joints are likely connected by a limb.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Distance isn\'t the primary factor; alignment is. You can have a long valid limb.')">The candidate joints are far apart.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'Occlusion usually lowers the confidence, it doesn\'t result in a high integral score.')">The limb is occluded.</div>
            <div class="choice-option" data-correct="false" onclick="selectChoice(this, false, 'This would result in a low score (near zero).')">The connection is invalid.</div>
        </div>
    </div>
    <div class="continue-button" id="continue-after-test-knowledge" onclick="showNextSection(26)" style="display: none;">Continue</div>
</section>

<!-- Section 26: Conclusion -->
<section id="section26">
    <p>You now have a solid understanding of how computers 'see' human structures. From simple regression to advanced vector fields, these techniques form the backbone of modern interaction design.</p>
</section>

<button id="markCompletedBtn" class="mark-completed-button" onclick="toggleCompleted()">✓ Mark as Completed</button>
</div>

<script>
let currentSection = 1;
const totalSections = 26;

updateProgress();
if (currentSection === totalSections) {
    const completedButton = document.getElementById('markCompletedBtn');
    if (completedButton) completedButton.classList.add('show');
}

function showNextSection(nextSectionId) {
    const nextSectionElement = document.getElementById(`section${nextSectionId}`);
    const currentButton = event && event.target;
    if (!nextSectionElement) return;
    if (currentButton && currentButton.classList.contains('continue-button')) {
        currentButton.style.display = 'none';
    }
    nextSectionElement.classList.add('visible');
    currentSection = nextSectionId;
    updateProgress();
    if (currentSection === totalSections) {
        const completedButton = document.getElementById('markCompletedBtn');
        if (completedButton) completedButton.classList.add('show');
    }
    setTimeout(() => { nextSectionElement.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 200);
}

function updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progress = (currentSection / totalSections) * 100;
    progressBar.style.width = `${progress}%`;
}

function revealAnswer(id) {
    const revealText = document.getElementById(id);
    const revealButton = event && event.target;
    if (revealText) {
        revealText.style.display = "block";
        revealText.classList.add('animate-in');
    }
    if (revealButton) {
        revealButton.style.display = "none";
    }
}

function selectChoice(element, isCorrect, explanation) {
    const choices = element.parentNode.querySelectorAll('.choice-option');
    choices.forEach(choice => {
        choice.classList.remove('selected', 'correct', 'incorrect');
        const existing = choice.querySelector('.choice-explanation');
        if (existing) existing.remove();
    });
    element.classList.add('selected');
    element.classList.add(isCorrect ? 'correct' : 'incorrect');
    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'choice-explanation';
    explanationDiv.style.display = 'block';
    explanationDiv.innerHTML = `<strong>${isCorrect ? 'Correct!' : 'Not quite.'}</strong> ${explanation}`;
    element.appendChild(explanationDiv);
    
    // Only show continue button if answer is correct
    if (!isCorrect) return;
    
    // Check if we need to show the continue button for the final quiz
    const parentSection = element.closest('section');
    if (parentSection && parentSection.id === 'section25') {
        const continueButton = document.getElementById('continue-after-test-knowledge');
        if (continueButton && continueButton.style.display === 'none') {
            setTimeout(() => {
                continueButton.style.display = 'block';
                continueButton.classList.add('show-with-animation');
            }, 800);
        }
    }
}

document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight' || e.key === ' ') {
        const btn = document.querySelector(`#section${currentSection} .continue-button`);
        if (btn && btn.style.display !== 'none') {
            e.preventDefault();
            btn.click();
        }
    }
});

document.documentElement.style.scrollBehavior = 'smooth';

function toggleCompleted() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    const isCompleted = button.classList.contains('completed');
    if (!isCompleted) {
        try {
            if (window.parent && window.parent.ProgressTracker) {
                // Update specific lesson ID for this file
                let courseId = 'computer-vision';
                let pathId = 'pose-estimation'; // Updated path
                let moduleId = 'cv-ch21-m2-advanced'; // Updated module
                let lessonId = 'cv-ch21-l2-connecting-dots'; // Updated lesson ID
                
                if (window.parent.currentRoute) {
                    const route = window.parent.currentRoute;
                    if (route.courseId) courseId = route.courseId;
                    if (route.pathId) pathId = route.pathId;
                    if (route.moduleId) moduleId = route.moduleId;
                    if (route.lessonId) lessonId = route.lessonId;
                }
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.get('course')) courseId = urlParams.get('course');
                if (urlParams.get('path')) pathId = urlParams.get('path');
                if (urlParams.get('module')) moduleId = urlParams.get('module');
                if (urlParams.get('lesson')) lessonId = urlParams.get('lesson');
                window.parent.ProgressTracker.markLessonCompleted(courseId, pathId, moduleId, lessonId);
            }
        } catch (error) {
            console.error('Error with ProgressTracker:', error);
        }
        button.classList.add('completed');
        button.innerHTML = '✅ Completed!';
        triggerCelebration();
        localStorage.setItem('lesson_cv-ch21-m2-l2_completed', 'true');
    }
}

function triggerCelebration() {
    createConfetti();
    showSuccessMessage();
}

function createConfetti() {
    const confettiContainer = document.createElement('div');
    confettiContainer.className = 'confetti-container';
    document.body.appendChild(confettiContainer);
    const emojis = ['🎉', '🎊', '✨', '🌟', '🎈', '🏆', '👏', '🥳'];
    const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7'];
    for (let i = 0; i < 40; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            if (Math.random() > 0.6) {
                confetti.textContent = emojis[Math.floor(Math.random() * emojis.length)];
            } else {
                confetti.innerHTML = '●';
                confetti.style.color = colors[Math.floor(Math.random() * colors.length)];
            }
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.animationDelay = Math.random() * 2 + 's';
            document.querySelector('.confetti-container').appendChild(confetti);
        }, i * 50);
    }
    setTimeout(() => { if (confettiContainer.parentNode) confettiContainer.parentNode.removeChild(confettiContainer); }, 5000);
}

function showSuccessMessage() {
    const successMessage = document.createElement('div');
    successMessage.className = 'success-message';
    successMessage.innerHTML = '🎉 Lesson Completed! Great Job! 🎉';
    document.body.appendChild(successMessage);
    setTimeout(() => { if (successMessage.parentNode) successMessage.parentNode.removeChild(successMessage); }, 2500);
}

window.addEventListener('load', function() {
    const button = document.getElementById('markCompletedBtn');
    if (!button) return;
    // Check local storage for completion
    const isCompleted = localStorage.getItem('lesson_cv-ch21-m2-l2_completed') === 'true';
    if (isCompleted) {
        button.classList.add('completed');
        button.innerHTML = '✅ Completed!';
    }
});
</script>
</body>
</html>