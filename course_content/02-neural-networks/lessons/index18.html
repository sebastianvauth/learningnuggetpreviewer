<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Logic: Can a Neuron Do AND, OR, NOT?</title>
  <style>
      body {
          font-family: Arial, sans-serif;
          max-width: 800px;
          margin: 0 auto;
          padding: 20px;
          background-color: #ffffff;
          font-size: 150%;
      }
      section {
          margin-bottom: 20px;
          padding: 20px;
          background-color: #ffffff;
          display: none;
          opacity: 0;
          transition: opacity 0.5s ease-in;
      }
      h1, h2, h3, h4 {
          color: #333;
          margin-top: 20px;
      }
      p, li {
          line-height: 1.6;
          color: #444;
          margin-bottom: 20px;
      }
      ul {
          padding-left: 20px;
      }
      .image-placeholder, .interactive-placeholder, .continue-button, .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think {
          text-align: left;
      }
      .image-placeholder img, .interactive-placeholder img {
          max-width: 100%;
          height: auto;
          border-radius: 5px;
      }
      .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think {
          padding: 20px;
          border-radius: 8px;
          margin-top: 20px;
      }
      .vocab-section {
          background-color: #f0f8ff;
      }
      .vocab-section h3 {
          color: #1e90ff;
          font-size: 0.75em;
          margin-bottom: 5px;
          margin-top: 5px;
      }
      .vocab-section h4 {
          color: #000;
          font-size: 0.9em;
          margin-top: 10px;
          margin-bottom: 8px;
      }
      .vocab-term {
          font-weight: bold;
          color: #1e90ff;
      }
      .why-it-matters {
          background-color: #ffe6f0;
      }
      .why-it-matters h3 {
          color: #d81b60;
          font-size: 0.75em;
          margin-bottom: 5px;
          margin-top: 5px;
      }
      .stop-and-think {
          background-color: #e6e6ff;
      }
      .stop-and-think h3 {
          color: #4b0082;
          font-size: 0.75em;
          margin-bottom: 5px;
          margin-top: 5px;
      }
      .continue-button {
          display: inline-block;
          padding: 10px 20px;
          margin-top: 15px;
          color: #ffffff;
          background-color: #007bff;
          border-radius: 5px;
          text-decoration: none;
          cursor: pointer;
      }
      .reveal-button {
          display: inline-block;
          padding: 10px 20px;
          margin-top: 15px;
          color: #ffffff;
          background-color: #4b0082;
          border-radius: 5px;
          text-decoration: none;
          cursor: pointer;
      }
      .test-your-knowledge {
          background-color: #e6ffe6; /* Light green background */
      }
      .test-your-knowledge h3 {
          color: #28a745; /* Dark green heading */
          font-size: 0.75em;
          margin-bottom: 5px;
          margin-top: 5px;
      }
      .test-your-knowledge h4 {
          color: #000;
          font-size: 0.9em;
          margin-top: 10px;
          margin-bottom: 8px;
      }
      .test-your-knowledge p {
          margin-bottom: 15px;
      }
      .check-button {
          display: inline-block;
          padding: 10px 20px;
          margin-top: 15px;
          color: #ffffff;
          background-color: #28a745; /* Green background */
          border-radius: 5px;
          text-decoration: none;
          cursor: pointer;
          border: none;
          font-size: 1em;
      }
      .option {
          margin-bottom: 10px;
          padding: 10px;
          border: 1px solid #ddd;
          border-radius: 5px;
          cursor: pointer;
      }
      .option:hover {
          background-color: #f5f5f5;
      }
      .option.selected {
          background-color: #d4edda;
          border-color: #c3e6cb;
      }
      .option.correct {
          background-color: #d4edda;
          border-color: #c3e6cb;
      }
      .option.incorrect {
          background-color: #f8d7da;
          border-color: #f5c6cb;
      }
      .explanation {
          margin-top: 10px;
          padding: 10px;
          background-color: #f8f9fa;
          border-radius: 5px;
          display: none;
      }
      .math-steps {
          background-color: #f9f9f9;
          padding: 15px;
          border-radius: 8px;
          margin: 15px 0;
      }
      .math-step {
          margin-bottom: 15px;
          padding-bottom: 15px;
          border-bottom: 1px solid #eee;
      }
      .math-step:last-child {
          border-bottom: none;
      }
      .math-step-title {
          font-weight: bold;
          margin-bottom: 5px;
      }
      .math-step-explanation {
          margin: 5px 0;
      }
      .math-step-result {
          color: #28a745;
          font-weight: bold;
      }
      .interactive-container {
          background-color: #f5f5f5;
          padding: 20px;
          border-radius: 8px;
          margin: 20px 0;
      }
      .slider-container {
          margin: 15px 0;
      }
      .slider-label {
          display: inline-block;
          width: 50px;
          font-weight: bold;
      }
      .slider {
          width: 200px;
          margin: 0 10px;
      }
      .slider-value {
          display: inline-block;
          width: 50px;
          text-align: right;
      }
      .plot-container {
          width: 300px;
          height: 300px;
          margin: 20px auto;
          position: relative;
          border: 1px solid #ddd;
          background-color: white;
      }
      .plot-point {
          position: absolute;
          width: 10px;
          height: 10px;
          border-radius: 50%;
          transform: translate(-50%, -50%);
      }
      .plot-line {
          position: absolute;
          background-color: #007bff;
          height: 2px;
          transform-origin: 0 0;
      }
      .plot-axis {
          position: absolute;
          background-color: #333;
      }
      .plot-axis-x {
          width: 100%;
          height: 1px;
          bottom: 50%;
      }
      .plot-axis-y {
          height: 100%;
          width: 1px;
          left: 50%;
      }
      .plot-label {
          position: absolute;
          font-size: 12px;
      }
      .faq-section {
          background-color: #fffbea; /* Light yellow background */
      }
      .faq-section h3 {
          color: #ffcc00; /* Bright yellow heading */
          font-size: 0.75em;
          margin-bottom: 5px;
          margin-top: 5px;
      }
      .faq-section h4 {
          color: #000;
          font-size: 0.9em;
          margin-top: 10px;
          margin-bottom: 8px;
      }
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <section id="section1">
      <div class="image-placeholder">
          <img src="/placeholder.svg?height=300&width=600" alt="A cartoon brain flexing its bicep, which is shaped like a logic gate (AND/OR gate symbol). Caption: 'Neural Networks: Not Just for Cats and Dogs... They Do Logic Too!'">
      </div>
      <h1>Lesson 18: Simple Logic: Can a Neuron Do AND, OR, NOT?</h1>
      <h2>AI Does Logic Puzzles!</h2>
      <p>Hey logic masters! We've been on quite a journey, building up our understanding of neural networks from individual neurons to complex layers and activation functions like Softmax. We've seen they can tackle big tasks like image classification.</p>
      <p>But can these sophisticated structures handle the most fundamental building blocks of computation – basic logical operations like AND, OR, and NOT? It might seem like a step back, but understanding if (and how) a simple neuron can perform these operations gives us deep insights into their capabilities and limitations, especially concerning something called 'linear separability'. Let's put a single artificial neuron to the test! (This lesson draws from Slides 29 & 30).</p>
      <div class="continue-button" onclick="showNextSection(2)">Continue</div>
  </section>

  <section id="section2">
      <h2>The AND Challenge: Can One Neuron Do It?</h2>
      <p>Let's start with the logical <strong>AND</strong> operation. Remember how it works?</p>
      <ul>
          <li>$$0 \text{ AND } 0 = 0$$</li>
          <li>$$0 \text{ AND } 1 = 0$$</li>
          <li>$$1 \text{ AND } 0 = 0$$</li>
          <li>$$1 \text{ AND } 1 = 1$$</li>
      </ul>
      <p>The AND operation outputs 1 (True) <em>only if both</em> its inputs are 1 (True). Otherwise, it outputs 0 (False).</p>
      <p>Our challenge: Can we configure a <strong>single artificial neuron</strong> (a perceptron) with two inputs $$x_1$$, $$x_2$$, a bias, and a <strong>Sigmoid activation function $$\phi$$</strong> to behave exactly like an AND gate? (Referencing Slide 29).</p>
      
      <div class="image-placeholder">
          <img src="/placeholder.svg?height=300&width=600" alt="A diagram of a single neuron (perceptron) set up for the AND operation, based on Slide 29: Inputs: x1 and x2. A '+1' input for the bias. Weights shown explicitly: From x1 to Σ: w1 = 150, From x2 to Σ: w2 = 150, From +1 (bias input) to Σ: wb = -200 (this is the bias b itself). These feed into a Summation unit (Σ), which produces χ (or z). χ then goes into an activation function φ (labeled as Sigmoid). The final output is φ(χ).">
      </div>
      
      <p>Let's try to find some weights ($$w_1$$, $$w_2$$) and a bias ($$b$$) that make this happen. The folks who made Slide 29 found some good ones for us: $$w_1 = 150$$, $$w_2 = 150$$, and $$b = -200$$.</p>
      
      <p>So, the net input $$\chi$$ (or $$z$$) to our Sigmoid function will be:<br>
      $$\chi = (150 \times x_1) + (150 \times x_2) - 200$$</p>
      
      <p>And the neuron's output will be $$\phi(\chi)$$, where $$\phi$$ is the Sigmoid function $$1 / (1 + e^{-\chi})$$.</p>
      
      <div class="math-steps">
          <h3>Testing the AND Neuron</h3>
          
          <div class="math-step">
              <div class="math-step-title">Case 1: Inputs $$x_1=0, x_2=0$$ (Target AND = 0)</div>
              <div class="math-step-equation">\[ \chi = (150 \times 0) + (150 \times 0) - 200 = -200 \]</div>
              <div class="math-step-explanation">Output $$\phi(-200)$$. Since -200 is a large negative number, $$e^{-(-200)}$$ is huge, so $$\phi(-200) \approx 0$$.</div>
              <div class="math-step-result">Matches Target!</div>
          </div>
          
          <div class="math-step">
              <div class="math-step-title">Case 2: Inputs $$x_1=0, x_2=1$$ (Target AND = 0)</div>
              <div class="math-step-equation">\[ \chi = (150 \times 0) + (150 \times 1) - 200 = 150 - 200 = -50 \]</div>
              <div class="math-step-explanation">Output $$\phi(-50)$$. Again, -50 is quite negative, so $$\phi(-50) \approx 0$$.</div>
              <div class="math-step-result">Matches Target!</div>
          </div>
          
          <div class="math-step">
              <div class="math-step-title">Case 3: Inputs $$x_1=1, x_2=0$$ (Target AND = 0)</div>
              <div class="math-step-equation">\[ \chi = (150 \times 1) + (150 \times 0) - 200 = 150 - 200 = -50 \]</div>
              <div class="math-step-explanation">Output $$\phi(-50) \approx 0$$.</div>
              <div class="math-step-result">Matches Target!</div>
          </div>
          
          <div class="math-step">
              <div class="math-step-title">Case 4: Inputs $$x_1=1, x_2=1$$ (Target AND = 1)</div>
              <div class="math-step-equation">\[ \chi = (150 \times 1) + (150 \times 1) - 200 = 300 - 200 = 100 \]</div>
              <div class="math-step-explanation">Output $$\phi(100)$$. Since 100 is a large positive number, $$e^{-100}$$ is tiny (close to 0), so $$\phi(100) \approx 1 / (1 + 0) = 1$$.</div>
              <div class="math-step-result">Matches Target!</div>
          </div>
      </div>
      
      <p>Success! With these specific weights and bias, our single neuron with a Sigmoid activation perfectly mimics the AND operation. If the output is < 0.5 we'd call it 0, and if >= 0.5 we'd call it 1. Our neuron correctly classifies all four input patterns.</p>
      
      <div class="continue-button" onclick="showNextSection(3)">Continue</div>
  </section>

  <section id="section3">
      <h2>The Magic Line: Linear Separability</h2>
      <p>So, why can a single neuron (a perceptron) solve the AND problem? The answer lies in a concept called <strong>Linear Separability</strong>. (Referencing Slide 30).</p>
      
      <p>A problem (or a logical function) is <strong>linearly separable</strong> if you can draw a single straight line (or in higher dimensions, a flat plane or hyperplane) that completely separates the input patterns that produce one output (e.g., '1' or 'True') from the input patterns that produce the other output (e.g., '0' or 'False').</p>
      
      <div class="image-placeholder">
          <img src="/placeholder.svg?height=400&width=600" alt="A dynamic version of the plots from Slide 30. AND Plot: Show a 2D graph with axes x1 (0 to 1) and x2 (0 to 1). Plot the four points: (0,0)-Red, (0,1)-Red, (1,0)-Red, (1,1)-Green. Animate a dashed line appearing that clearly separates the green (1,1) point from the three red points. Equation of the line (e.g., 150x1 + 150x2 - 200 = 0, or simplified x1 + x2 = 1.33) could be shown. Points on one side of the line result in χ < 0 (output ~0), on the other side χ > 0 (output ~1). OR Plot: Similar 2D graph. Points: (0,0)-Red, (0,1)-Green, (1,0)-Green, (1,1)-Green. Animate a different dashed line separating the red (0,0) point from the three green points. NOT Plot (1D): A 1D number line for input x (0 and 1). Point x=0 is Green (NOT 0 is 1). Point x=1 is Red (NOT 1 is 0). Animate a separating point (threshold) appearing between 0 and 1 on the line.">
      </div>
      
      <p>As you can see from the plots:</p>
      <ul>
          <li>For <strong>AND</strong>, we can draw a line to isolate the $$(1,1)$$ input (which gives output 1) from the other three inputs (which give output 0).</li>
          <li>For <strong>OR</strong> (outputs 1 if <em>either or both</em> inputs are 1), we can draw a line to isolate $$(0,0)$$ (output 0) from the other three inputs (output 1).</li>
          <li>For <strong>NOT</strong> (which just takes one input $$x$$ and outputs $$1-x$$), we can find a threshold on a 1D line to separate the $$x=0$$ case from the $$x=1$$ case.</li>
      </ul>
      
      <p>A single perceptron is essentially learning the equation of this separating line (its <strong>decision boundary</strong>). The weights determine the slope of the line, and the bias determines where it intersects the axes (its position).</p>
      
      <div class="vocab-section">
          <h3>Build Your Vocab</h3>
          <h4 class="vocab-term">Linearly Separable</h4>
          <p>A property of a set of data points belonging to two classes. The set is linearly separable if there exists at least one hyperplane (a line in 2D, a plane in 3D, etc.) that perfectly divides the data points such that all points of one class lie on one side of the hyperplane, and all points of the other class lie on the other side.</p>
      </div>
      
      <div class="why-it-matters">
          <h3>Why It Matters</h3>
          <p>Understanding linear separability is crucial because it defines the limit of what a <em>single</em> perceptron (or any linear classifier) can learn. If a problem isn't linearly separable, a single neuron just won't cut it, no matter how you tweak its weights and bias. This was a major realization in the early days of AI!</p>
      </div>
      
      <div class="continue-button" onclick="showNextSection(4)">Continue</div>
  </section>

  <section id="section4">
      <h2>Try It Yourself: Finding the Line!</h2>
      <p>Let's get a feel for this. Can you find the line for the AND gate?</p>
      
      <div class="interactive-container">
          <h3>Perceptron Playground for Logic Gates</h3>
          
          <div class="slider-container">
              <span class="slider-label">w1:</span>
              <input type="range" min="-200" max="200" value="150" class="slider" id="w1Slider">
              <span class="slider-value" id="w1Value">150</span>
          </div>
          
          <div class="slider-container">
              <span class="slider-label">w2:</span>
              <input type="range" min="-200" max="200" value="150" class="slider" id="w2Slider">
              <span class="slider-value" id="w2Value">150</span>
          </div>
          
          <div class="slider-container">
              <span class="slider-label">bias:</span>
              <input type="range" min="-300" max="100" value="-200" class="slider" id="biasSlider">
              <span class="slider-value" id="biasValue">-200</span>
          </div>
          
          <div class="plot-container" id="andPlot">
              <!-- Plot will be drawn here by JavaScript -->
              <div class="plot-axis plot-axis-x"></div>
              <div class="plot-axis plot-axis-y"></div>
              
              <!-- Points for AND gate -->
              <div class="plot-point" style="left: 25%; top: 75%; background-color: red;" id="point00"></div>
              <div class="plot-point" style="left: 25%; top: 25%; background-color: red;" id="point01"></div>
              <div class="plot-point" style="left: 75%; top: 75%; background-color: red;" id="point10"></div>
              <div class="plot-point" style="left: 75%; top: 25%; background-color: green;" id="point11"></div>
              
              <!-- Decision boundary line -->
              <div class="plot-line" id="decisionLine"></div>
              
              <!-- Labels -->
              <div class="plot-label" style="left: 15%; top: 85%;">(0,0)</div>
              <div class="plot-label" style="left: 15%; top: 15%;">(0,1)</div>
              <div class="plot-label" style="left: 85%; top: 85%;">(1,0)</div>
              <div class="plot-label" style="left: 85%; top: 15%;">(1,1)</div>
              
              <div class="plot-label" style="left: 95%; top: 50%;">x1</div>
              <div class="plot-label" style="left: 50%; top: 5%;">x2</div>
          </div>
          
          <p id="equationDisplay">Decision boundary: 150*x1 + 150*x2 - 200 = 0</p>
          <p id="classificationResult">All points correctly classified for AND gate!</p>
      </div>
      
      <p>It might take a bit of fiddling, but you'll find that you <em>can</em> adjust the weights and bias to draw a line that correctly separates the AND conditions. This confirms that AND is linearly separable and solvable by a single neuron.</p>
      
      <p>(You could try the same for OR too! What weights and bias would work for OR?)</p>
      
      <div class="test-your-knowledge">
          <h3>Test Your Knowledge</h3>
          <h4>If a classification problem with two input features is NOT linearly separable, can a single perceptron with a Sigmoid activation function solve it perfectly?</h4>
          
          <div class="option" onclick="selectOption(0)">
              Yes, the Sigmoid function's non-linearity will allow it to find a solution.
          </div>
          <div class="option" onclick="selectOption(1)">
              No, a single perceptron can only solve linearly separable problems, regardless of the activation function.
          </div>
          <div class="option" onclick="selectOption(2)">
              Maybe, it depends on how complex the non-linear separation is.
          </div>
          
          <div class="explanation" id="explanation0">
              While the Sigmoid function <em>is</em> non-linear, a single perceptron still defines a linear decision boundary in its input space. The non-linearity of the Sigmoid just 'squashes' the output, it doesn't change the fundamental linearity of what the neuron is separating <em>before</em> squashing.
          </div>
          <div class="explanation" id="explanation1">
              Correct! The decision boundary formed by $$w_1 \times x_1 + w_2 \times x_2 + ... + b = \text{threshold\_for\_activation}$$ is inherently linear. The activation function acts <em>after</em> this linear separation is made.
          </div>
          <div class="explanation" id="explanation2">
              If it's not linearly separable at all, a single perceptron won't be able to find a perfect solution. It might find a 'best fit' line, but it will make errors.
          </div>
          
          <button class="check-button" id="checkButton" style="display: none;" onclick="checkAnswer()">Check Answer</button>
      </div>
      
      <div class="continue-button" onclick="showNextSection(5)">Continue</div>
  </section>

  <section id="section5">
      <h2>The Limit of a Line</h2>
      <p>So, a single neuron is a linear classifier. It can draw lines (or planes, or hyperplanes) to separate things. This is powerful for problems where such a separation exists.</p>
      
      <p>But what about problems where you <em>can't</em> draw a single straight line to separate the classes? This is where the story gets really interesting, and where the true power of <em>multi-layer</em> neural networks, which can create much more complex, non-linear decision boundaries, comes into play.</p>
      
      <p>In our very next lesson, we're going to encounter a classic example of such a non-linearly separable problem: the <strong>XOR (Exclusive OR) problem</strong>. It famously stumped single perceptrons but became a great demonstration of what neural networks with hidden layers could achieve. Get ready for a fun challenge!</p>
      
      <div class="image-placeholder">
          <img src="/placeholder.svg?height=300&width=600" alt="A straight line trying and failing to separate a complex, intertwined pattern of red and green dots (representing a non-linearly separable problem). The line looks frustrated. Caption: 'Some puzzles need more than just a straight line!'">
      </div>
  </section>

  <script>
      // Show the first section initially
      document.getElementById("section1").style.display = "block";
      document.getElementById("section1").style.opacity = "1";

      // Function to show the next section
      function showNextSection(nextSectionId) {
          const currentButton = event.target;
          const nextSection = document.getElementById("section" + nextSectionId);
          
          currentButton.style.display = "none";
          
          nextSection.style.display = "block";
          setTimeout(() => {
              nextSection.style.opacity = "1";
          }, 10);

          setTimeout(() => {
              nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }, 500);
      }

      // Variables for the interactive perceptron playground
      let w1 = 150;
      let w2 = 150;
      let bias = -200;
      let selectedOption = null;

      // Initialize the interactive elements when the page loads
      window.onload = function() {
          // Set up sliders
          const w1Slider = document.getElementById("w1Slider");
          const w2Slider = document.getElementById("w2Slider");
          const biasSlider = document.getElementById("biasSlider");
          
          w1Slider.addEventListener("input", updatePerceptron);
          w2Slider.addEventListener("input", updatePerceptron);
          biasSlider.addEventListener("input", updatePerceptron);
          
          // Initial update
          updatePerceptron();
      };

      // Update the perceptron visualization based on slider values
      function updatePerceptron() {
          // Get slider values
          w1 = parseInt(document.getElementById("w1Slider").value);
          w2 = parseInt(document.getElementById("w2Slider").value);
          bias = parseInt(document.getElementById("biasSlider").value);
          
          // Update displayed values
          document.getElementById("w1Value").textContent = w1;
          document.getElementById("w2Value").textContent = w2;
          document.getElementById("biasValue").textContent = bias;
          
          // Update equation display
          document.getElementById("equationDisplay").textContent = 
              `Decision boundary: ${w1}*x1 + ${w2}*x2 + ${bias} = 0`;
          
          // Update decision boundary line
          updateDecisionBoundary();
          
          // Update point classifications
          updatePointClassifications();
      }

      // Update the decision boundary line visualization
      function updateDecisionBoundary() {
          const line = document.getElementById("decisionLine");
          
          // If both w1 and w2 are 0, we can't draw a meaningful line
          if (w1 === 0 && w2 === 0) {
              line.style.display = "none";
              return;
          }
          
          // Calculate line endpoints
          // For simplicity, we'll use the plot boundaries (0-100%)
          let x1, y1, x2, y2;
          
          if (Math.abs(w1) > Math.abs(w2)) {
              // Line intersects top and bottom edges
              y1 = 0;
              x1 = (-bias - w2 * 1) / w1;
              x1 = (x1 * 50) + 50; // Scale to plot coordinates
              
              y2 = 100;
              x2 = (-bias - w2 * 0) / w1;
              x2 = (x2 * 50) + 50; // Scale to plot coordinates
          } else {
              // Line intersects left and right edges
              x1 = 0;
              y1 = (-bias - w1 * 0) / w2;
              y1 = 100 - ((y1 * 50) + 50); // Scale to plot coordinates and invert (y-axis is inverted in CSS)
              
              x2 = 100;
              y2 = (-bias - w1 * 1) / w2;
              y2 = 100 - ((y2 * 50) + 50); // Scale to plot coordinates and invert
          }
          
          // Position and rotate the line
          const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
          
          line.style.display = "block";
          line.style.width = `${length}%`;
          line.style.left = `${x1}%`;
          line.style.top = `${y1}%`;
          line.style.transform = `rotate(${angle}deg)`;
      }

      // Update the classification of the four points
      function updatePointClassifications() {
          // Calculate outputs for each input combination
          const output00 = sigmoid((w1 * 0) + (w2 * 0) + bias);
          const output01 = sigmoid((w1 * 0) + (w2 * 1) + bias);
          const output10 = sigmoid((w1 * 1) + (w2 * 0) + bias);
          const output11 = sigmoid((w1 * 1) + (w2 * 1) + bias);
          
          // Update point colors based on classification
          document.getElementById("point00").style.backgroundColor = output00 >= 0.5 ? "green" : "red";
          document.getElementById("point01").style.backgroundColor = output01 >= 0.5 ? "green" : "red";
          document.getElementById("point10").style.backgroundColor = output10 >= 0.5 ? "green" : "red";
          document.getElementById("point11").style.backgroundColor = output11 >= 0.5 ? "green" : "red";
          
          // Check if the classification matches the AND gate truth table
          const correctAND = 
              output00 < 0.5 && 
              output01 < 0.5 && 
              output10 < 0.5 && 
              output11 >= 0.5;
          
          // Update result message
          document.getElementById("classificationResult").textContent = 
              correctAND ? "All points correctly classified for AND gate!" : "Not matching AND gate truth table yet. Keep adjusting!";
          document.getElementById("classificationResult").style.color = 
              correctAND ? "#28a745" : "#dc3545";
      }

      // Sigmoid activation function
      function sigmoid(x) {
          return 1 / (1 + Math.exp(-x));
      }

      // Handle option selection in the quiz
      function selectOption(index) {
          // Clear previous selection
          const options = document.querySelectorAll('.option');
          options.forEach(option => {
              option.classList.remove('selected');
          });
          
          // Mark the selected option
          options[index].classList.add('selected');
          selectedOption = index;
          
          // Show the check button
          document.getElementById('checkButton').style.display = 'inline-block';
      }

      // Check the answer in the quiz
      function checkAnswer() {
          if (selectedOption === null) return;
          
          // Clear previous results
          const options = document.querySelectorAll('.option');
          options.forEach((option, index) => {
              option.classList.remove('correct', 'incorrect');
              document.getElementById(`explanation${index}`).style.display = 'none';
          });
          
          // Mark correct/incorrect and show explanation
          const correctIndex = 1; // The correct answer is the second option (index 1)
          
          if (selectedOption === correctIndex) {
              options[selectedOption].classList.add('correct');
          } else {
              options[selectedOption].classList.add('incorrect');
              options[correctIndex].classList.add('correct');
          }
          
          document.getElementById(`explanation${selectedOption}`).style.display = 'block';
          
          // Hide the check button
          document.getElementById('checkButton').style.display = 'none';
      }

      // Function to reveal answers in the "Stop and Think" sections
      function revealAnswer(id) {
          const revealText = document.getElementById(id);
          const revealButton = event.target;
          
          revealText.style.display = "block";
          revealButton.style.display = "none";
      }
  </script>
</body>
</html>